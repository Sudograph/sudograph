# TODO we might want to set up individual canisters with individual schemas to test per test

# TODO this schema was designed for order

# TODO make sure to test relation one and relation many, searching by id
type User {
    id: ID!
    blob: Blob!
    bool: Boolean!
    date: Date!
    float: Float!
    int: Int!
    json: JSON!
    string: String!
    food: Food!

    blob_nullable: Blob
    bool_nullable: Boolean
    date_nullable: Date
    float_nullable: Float
    int_nullable: Int
    json_nullable: JSON
    string_nullable: String
    food_nullable: Food

    hobby: Hobby!
    hobby_nullable: Hobby

    # hobbies: [Hobby!]!
}

type Hobby {
    id: ID!
#     blob: Blob!
#     bool: Boolean!
#     date: Date!
#     float: Float!
#     int: Int!
#     json: JSON!
#     string: String!

#     blob_nullable: Blob
#     bool_nullable: Boolean
#     date_nullable: Date
#     float_nullable: Float
#     int_nullable: Int
#     json_nullable: JSON
#     string_nullable: String

#     users: [User!]!
#     lobbies: [Lobby!]!
}

# type Lobby {
#     id: ID!
#     blob: Blob!
#     bool: Boolean!
#     date: Date!
#     float: Float!
#     int: Int!
#     json: JSON!
#     string: String!

#     blob_nullable: Blob
#     bool_nullable: Boolean
#     date_nullable: Date
#     float_nullable: Float
#     int_nullable: Int
#     json_nullable: JSON
#     string_nullable: String
# }

enum Food {
    CARROTS
    PEANUTS
    RANCH
    POTATOES
}
# TODO this schema was designed for order

# TODO this schema was designed for order
# type User {
#     id: ID!
#     blob: Blob!
#     bool: Boolean!
#     date: Date!
#     float: Float!
#     int: Int!
#     json: JSON!
#     string: String!

#     blob_nullable: Blob
#     bool_nullable: Boolean
#     date_nullable: Date
#     float_nullable: Float
#     int_nullable: Int
#     json_nullable: JSON
#     string_nullable: String

#     hobbies: [Hobby!]!
# }

# type Hobby {
#     id: ID!
#     blob: Blob!
#     bool: Boolean!
#     date: Date!
#     float: Float!
#     int: Int!
#     json: JSON!
#     string: String!

#     blob_nullable: Blob
#     bool_nullable: Boolean
#     date_nullable: Date
#     float_nullable: Float
#     int_nullable: Int
#     json_nullable: JSON
#     string_nullable: String

#     users: [User!]!
#     lobbies: [Lobby!]!
# }

# type Lobby {
#     id: ID!
#     blob: Blob!
#     bool: Boolean!
#     date: Date!
#     float: Float!
#     int: Int!
#     json: JSON!
#     string: String!

#     blob_nullable: Blob
#     bool_nullable: Boolean
#     date_nullable: Date
#     float_nullable: Float
#     int_nullable: Int
#     json_nullable: JSON
#     string_nullable: String
# }
# TODO this schema was designed for order

# TODO this schema was designed for limits and offsets
# type User {
    # id: ID!
    # ducks: [Duck!]!
# }

# type Duck {
#     id: ID!
#     hunters: [User!]!
#     # ponds: [Pond!]!
# }

# type Pond {
#     id: ID!
# }
# TODO this schema was designed for limits and offsets

# TODO we want to generate this file automatically using arbitraries somehow
# TODO we will want to configure its complexity...it would be nice to vary
# TODO the number of object types, fields per object type, etc

# type User {
#     id: ID!
#     username: String!
#     job_1: Job! @relation(name: "User:job_1::Job:user_1")
#     job_2: Job! @relation(name: "User:job_2::Job:user_2")
#     job_3: Job!
#     job_4: Job
# }

# type Job {
#     id: ID!
#     title: String!
#     user_1: User @relation(name: "User:job_1::Job:user_1")
#     user_2: User @relation(name: "User:job_2::Job:user_2")
# }

# type User {
    # id: ID!
    # username: String!
    # username_nullable: String
    # age: Int!
    # age_nullable: Int
    # color: Color!
    # color_nullable: Color
    # height: Float!
    # height_nullable: Float
    # citizen: Boolean!
    # citizen_nullable: Boolean
    # birthdate: Date!
    # birthdate_nullable: Date
    # bytes: Blob! # TODO blobs do not work without that special function
    # bytes_nullable: Blob # TODO blobs do not work without that special function
    # meta: JSON!
    # meta_nullable: JSON

    # identity: Identity!
    # identity_nullable: Identity
    # votes: [Vote!]!
    # votes_nullable: [Vote!]

    # TODO just testing different combinations for the read tests, make sure to test identity alone again
    # first_horse: Horse! @relation(name: "User:first_horse::Horse:first_rider")
    # second_horse: Horse @relation(name: "User:second_horse::Horse:second_rider")
    # ducks: [Duck!]! @relation(name: "User:ducks::Duck:hunter")
    # ducklings: [Duck!] @relation(name: "User:ducklings::Duck:foster_parent")
    # bacteria: [Bacterium!]! @relation(name: "User:bacteria::Bacterium:hosts")
    # good_bacteria: [Bacterium!] @relation(name: "User:good_bacteria::Bacterium:good_hosts")

    # TODO there are a few more many-to-many combinations to try, non-nullable to nullable and nullable to non-nullable

    # best_friend: User
    # best_friends: [User!]!
    # bestest_friends: [User!]

    # these are for disconnect tests
    # plant_0: Plant
    # plant_1: Plant @relation(name: "User:plant_1::Plant::user_1")
    # plant_2: Plant @relation(name: "User:plant_2::Plant::user_2")
    # plant_3: Plant @relation(name: "User:plant_3::Plant::user_3")
    # plant_4: Plant @relation(name: "User:plant_4::Plant::user_4")

    # flowers_0: [Flower!]!
    # flowers_1: [Flower!]! @relation(name: "User:flowers_1::Flower:user_1")
    # flowers_2: [Flower!]! @relation(name: "User:flowers_2::Flower:user_2")
    # flowers_3: [Flower!]! @relation(name: "User:flowers_3::Flower:user_3")
    # flowers_4: [Flower!]! @relation(name: "User:flowers_4::Flower:user_4")
# }

# type Duck {
#     id: ID!
# #     hunter: User! @relation(name: "User:ducks::Duck:hunter")
# #     foster_parent: User @relation(name: "User:ducklings::Duck:foster_parent")
# }

# TODO add to the tests, if you set one side of a relation to null, the other side should be checked to see
# TODO that the appropriate thing happened
# type Horse {
#     id: ID!
#     first_rider: User @relation(name: "User:first_horse::Horse:first_rider")
#     second_rider: User @relation(name: "User:second_horse::Horse:second_rider")
# }

# type Flower {
#     id: ID!
#     user_1: User! @relation(name: "User:flowers_1::Flower:user_1")
#     user_2: User @relation(name: "User:flowers_2::Flower:user_2")
#     user_3: [User!]! @relation(name: "User:flowers_3::Flower:user_3")
#     user_4: [User!] @relation(name: "User:flowers_4::Flower:user_4")
# }

# type Plant {
#     id: ID!
#     # user_1: User! @relation(name: "User:plant_1::Plant::user_1")
#     user_2: User @relation(name: "User:plant_2::Plant::user_2")
#     user_3: [User!]! @relation(name: "User:plant_3::Plant::user_3")
#     user_4: [User!] @relation(name: "User:plant_4::Plant::user_4")
# }

# type Identity {
#     id: ID!
# }

# type Vote {
#     id: ID!
# }

# type Bacterium {
#     id: ID!
#     hosts: [User!]! @relation(name: "User:bacteria::Bacterium:hosts")
#     good_hosts: [User!] @relation(name: "User:good_bacteria::Bacterium:good_hosts")
# }

# enum Color {
#     RED
#     WHITE
#     BLUE
#     GREEN
#     YELLOW
# }