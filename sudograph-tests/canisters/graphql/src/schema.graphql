# TODO we want to generate this file automatically using arbitraries somehow
# TODO we will want to configure its complexity...it would be nice to vary
# TODO the number of object types, fields per object type, etc

type User {
    id: ID!
    # username: String!
    # username_nullable: String
    # age: Int!
    # age_nullable: Int
    # color: Color!
    # color_nullable: Color
    # height: Float!
    # height_nullable: Float
    # citizen: Boolean!
    # citizen_nullable: Boolean
    # birthdate: Date!
    # birthdate_nullable: Date
    # bytes: Blob!
    # bytes_nullable: Blob
    # meta: JSON!
    # meta_nullable: JSON

    # identity: Identity!
    # identity_nullable: Identity
    # votes: [Vote!]!
    # votes_nullable: [Vote!]

    # horse: Horse! @relation(name: "User:horse::Horse:primary_rider") # TODO this is broken until we handle one-to-one nullables correctly
    # second_horse: Horse @relation(name: "User:second_horse::Horse:secondary_rider")
    # ducks: [Duck!]! @relation(name: "User:ducks::Duck:hunter")
    # ducklings: [Duck!] @relation(name: "User:ducklings::Duck:foster_parent")
    # bacteria: [Bacterium!]! @relation(name: "User:bacteria::Bacterium:hosts")
    # good_bacteria: [Bacterium!] @relation(name: "User:good_bacteria::Bacterium:good_hosts")

    # TODO there are a few more many-to-many combinations to try, non-nullable to nullable and nullable to non-nullable

    # best_friend: User
    # best_friends: [User!]!
    # bestest_friends: [User!]

    plant_0: Plant
    plant_1: Plant @relation(name: "User:plant_1::Plant::user_1")
    plant_2: Plant @relation(name: "User:plant_2::Plant::user_2")
    plant_3: Plant @relation(name: "User:plant_3::Plant::user_3")
    plant_4: Plant @relation(name: "User:plant_4::Plant::user_4")
}

type Plant {
    id: ID!
    user_1: User! @relation(name: "User:plant_1::Plant::user_1")
    user_2: User @relation(name: "User:plant_2::Plant::user_2")
    user_3: [User!]! @relation(name: "User:plant_3::Plant::user_3")
    user_4: [User!] @relation(name: "User:plant_4::Plant::user_4")
}

# type Identity {
#     id: ID!
# }

# type Vote {
#     id: ID!
# }

# TODO add to the tests, if you set one side of a relation to null, the other side should be checked to see
# TODO that the appropriate thing happened
# type Horse {
#     id: ID!
#     # primary_rider: User @relation(name: "User:horse::Horse:primary_rider")
#     secondary_rider: User @relation(name: "User:second_horse::Horse:secondary_rider")
# }

# type Duck {
#     id: ID!
#     hunter: User! @relation(name: "User:ducks::Duck:hunter")
#     foster_parent: User @relation(name: "User:ducklings::Duck:foster_parent")
# }

# type Bacterium {
#     id: ID!
#     hosts: [User!]! @relation(name: "User:bacteria::Bacterium:hosts")
#     good_hosts: [User!] @relation(name: "User:good_bacteria::Bacterium:good_hosts")
# }
# enum Color {
#     RED
#     WHITE
#     BLUE
#     GREEN
#     YELLOW
# }