<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sudograph</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="sudograph.html"><strong aria-hidden="true">1.</strong> Sudograph</a></li><li class="chapter-item expanded "><a href="vision-and-motivation.html"><strong aria-hidden="true">2.</strong> Vision and motivation</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li class="chapter-item expanded "><a href="quickest-of-quick-starts.html"><strong aria-hidden="true">4.</strong> Quickest of quick starts</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">5.</strong> Quick start</a></li><li class="chapter-item expanded "><a href="existing-project.html"><strong aria-hidden="true">6.</strong> Existing project</a></li><li class="chapter-item expanded "><a href="local-deployment.html"><strong aria-hidden="true">7.</strong> Local deployment</a></li><li class="chapter-item expanded "><a href="ic-deployment.html"><strong aria-hidden="true">8.</strong> IC deployment</a></li><li class="chapter-item expanded "><a href="wasm-binary-optimization.html"><strong aria-hidden="true">9.</strong> Wasm binary optimization</a></li><li class="chapter-item expanded "><a href="sudograph-client.html"><strong aria-hidden="true">10.</strong> Sudograph Client</a></li><li class="chapter-item expanded "><a href="agent-js.html"><strong aria-hidden="true">11.</strong> agent-js</a></li><li class="chapter-item expanded "><a href="schema.html"><strong aria-hidden="true">12.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema-scalars.html"><strong aria-hidden="true">12.1.</strong> Scalars</a></li><li class="chapter-item expanded "><a href="schema-objects.html"><strong aria-hidden="true">12.2.</strong> Objects</a></li><li class="chapter-item expanded "><a href="schema-relations.html"><strong aria-hidden="true">12.3.</strong> Relations</a></li><li class="chapter-item expanded "><a href="schema-custom-scalars.html"><strong aria-hidden="true">12.4.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="schema-custom-resolvers.html"><strong aria-hidden="true">12.5.</strong> Custom resolvers</a></li><li class="chapter-item expanded "><a href="schema-custom-directives.html"><strong aria-hidden="true">12.6.</strong> Custom directives</a></li><li class="chapter-item expanded "><a href="schema-sudograph-directives.html"><strong aria-hidden="true">12.7.</strong> Sudograph directives</a></li><li class="chapter-item expanded "><a href="schema-sudograph-settings.html"><strong aria-hidden="true">12.8.</strong> Sudograph settings</a></li></ol></li><li class="chapter-item expanded "><a href="generated-schema.html"><strong aria-hidden="true">13.</strong> Generated schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generated-schema-query.html"><strong aria-hidden="true">13.1.</strong> Query</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generated-schema-query-read.html"><strong aria-hidden="true">13.1.1.</strong> read</a></li></ol></li><li class="chapter-item expanded "><a href="generated-schema-mutation.html"><strong aria-hidden="true">13.2.</strong> Mutation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="generated-schema-mutation-create.html"><strong aria-hidden="true">13.2.1.</strong> create</a></li><li class="chapter-item expanded "><a href="generated-schema-mutation-update.html"><strong aria-hidden="true">13.2.2.</strong> update</a></li><li class="chapter-item expanded "><a href="generated-schema-mutation-delete.html"><strong aria-hidden="true">13.2.3.</strong> delete</a></li><li class="chapter-item expanded "><a href="generated-schema-mutation-init.html"><strong aria-hidden="true">13.2.4.</strong> init</a></li></ol></li><li class="chapter-item expanded "><a href="generated-schema-subscription.html"><strong aria-hidden="true">13.3.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="generated-schema-search.html"><strong aria-hidden="true">13.4.</strong> Search</a></li><li class="chapter-item expanded "><a href="generated-schema-limit.html"><strong aria-hidden="true">13.5.</strong> Limit</a></li><li class="chapter-item expanded "><a href="generated-schema-offset.html"><strong aria-hidden="true">13.6.</strong> Offset</a></li><li class="chapter-item expanded "><a href="generated-schema-order.html"><strong aria-hidden="true">13.7.</strong> Order</a></li></ol></li><li class="chapter-item expanded "><a href="authorization.html"><strong aria-hidden="true">14.</strong> Authorization</a></li><li class="chapter-item expanded "><a href="migrations.html"><strong aria-hidden="true">15.</strong> Migrations</a></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">16.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="multi-canister-scaling.html"><strong aria-hidden="true">17.</strong> Multi-canister scaling</a></li><li class="chapter-item expanded "><a href="custom-database-operations.html"><strong aria-hidden="true">18.</strong> Custom database operations</a></li><li class="chapter-item expanded "><a href="custom-async-graphql-integration.html"><strong aria-hidden="true">19.</strong> Custom async_graphql integration</a></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">20.</strong> Limitations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Sudograph</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sudograph"><a class="header" href="#sudograph">Sudograph</a></h1>
<p>Sudograph is a <a href="https://graphql.org/">GraphQL</a> database for the <a href="https://dfinity.org/">Internet Computer</a> (IC).</p>
<p>Its goal is to become the simplest way to develop applications for the IC. Developers start by defining a <a href="https://graphql.org/learn/schema/">GraphQL schema</a> using the <a href="https://www.digitalocean.com/community/tutorials/graphql-graphql-sdl">GraphQL SDL</a>. Once the schema is defined, it can be included within a canister and deployed to the IC. An entire relational database is generated from the schema, with GraphQL queries and mutations enabling a variety of <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations, including advanced querying over relational data.</p>
<p>Sudograph should be considered somewhere between alpha and beta software.</p>
<h1 id="vision-and-motivation"><a class="header" href="#vision-and-motivation">Vision and motivation</a></h1>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Multiple examples are located in the <a href="https://github.com/sudograph/sudograph/tree/main/examples">examples directory</a> in the <a href="https://github.com/sudograph/sudograph">Sudograph repository</a>.</p>
<p>Here's a list of possibly useful examples:</p>
<ul>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/basic">basic</a></li>
<li><a href="https://github.com/lastmjs/ethereum-archival-canister">Ethereum Archival Canister</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/files">files 1</a></li>
<li><a href="https://github.com/dansteren/files">files 2</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/intermediate">intermediate</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/miscellaneous">miscellaneous</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/motoko-custom-resolvers">motoko-custom-resolvers</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/rust-custom-resolvers">rust-custom-resolvers</a></li>
<li><a href="https://github.com/Ancez/sudograph-vue">sudograph-vue</a></li>
<li><a href="https://github.com/webi-ai/webi_api">webi_api</a></li>
</ul>
<h2 id="quickest-of-quick-starts-new-project"><a class="header" href="#quickest-of-quick-starts-new-project">Quickest of quick starts (new project)</a></h2>
<p>This section is designed to get you going completely from scratch. It assumes you want to have a frontend, a GraphQL playground, and the <code>graphql canister</code>. If you instead wish to integrate Sudograph into an existing project, see the <a href="./existing-project.html">Existing project section</a>.</p>
<p>If you've already got Node.js, npm, Rust, the wasm32-unknown-unknown Rust compilation target, and dfx 0.7.2 installed then just run the following commands:</p>
<pre><code class="language-bash">mkdir my-new-project
cd my-new-project
npx sudograph
dfx start --background
dfx deploy
</code></pre>
<p>Once deployed, you can visit the following canisters from a Chromium browser:</p>
<ul>
<li>playground: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a></li>
<li>frontend: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a></li>
</ul>
<p>If the above did not work, try the full installation steps in the actual <a href="./quick-start.html">quick start</a>.</p>
<p>More information is available for <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h2 id="quick-start-new-project"><a class="header" href="#quick-start-new-project">Quick start (new project)</a></h2>
<p>This section is designed to get you going completely from scratch. It assumes you want to have a frontend, a GraphQL playground, and the <code>graphql canister</code>. If you instead wish to integrate Sudograph into an existing project, see the <a href="./existing-project.html">Existing project section</a>.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You should have the following installed on your system:</p>
<ul>
<li>Node.js</li>
<li>npm</li>
<li>Rust</li>
<li>wasm32-unknown-unknown Rust compilation target</li>
<li>dfx 0.7.2</li>
</ul>
<p>If you already have the above installed, you can skip to <a href="quick-start.html#sudograph-generate">Sudograph generate</a>.</p>
<p>Run the following commands to install Node.js and npm. <a href="https://github.com/nvm-sh/nvm">nvm</a> is highly recommended and its use is shown below:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash

# restart your terminal

nvm install 14
</code></pre>
<p>Run the following command to install Rust and the wasm32-unknown-unknown target:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

rustup target add wasm32-unknown-unknown
</code></pre>
<p>Run the following command to install dfx 0.7.2:</p>
<pre><code class="language-bash"># Sudograph has been tested against version 0.7.2, so it is safest to install that specific version for now
DFX_VERSION=0.7.2 sh -ci &quot;$(curl -fsSL https://sdk.dfinity.org/install.sh)&quot;
</code></pre>
<h3 id="sudograph-generate"><a class="header" href="#sudograph-generate">Sudograph generate</a></h3>
<p>Start by making a new directory for your project. You then simply run the sudograph generate command:</p>
<pre><code class="language-bash">mkdir my-new-project

cd my-new-project

npx sudograph
</code></pre>
<h3 id="deployment"><a class="header" href="#deployment">Deployment</a></h3>
<p>Use the following links for more information about <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h1 id="existing-project"><a class="header" href="#existing-project">Existing project</a></h1>
<p>The <a href="./quickest-of-quick-starts.html">quickest of quick starts</a> and <a href="./quick-start.html">quick start</a> are both designed to get you started with an entire example project from scratch. If instead you wish to integrate Sudograph into an existing project, this section will help you to achieve that.</p>
<p>Basically you need to add a new Rust canister to your project and import and call the <code>graphql_database</code> procedural macro. If you're new to developing for the Internet Computer, you might want to check the <a href="https://sdk.dfinity.org/docs/quickstart/quickstart-intro.html">documentation</a> to get familiar with canister development. The detailed steps are listed out below, but looking at <a href="./examples.html">examples</a> might also help a lot.</p>
<p>Make sure you at least have Rust, the wasm32-unknown-unknown Rust compilation target, and dfx 0.7.2 installed on your system. If you need help setting all of that up, look at the <a href="http://localhost:3000/quick-start.html#prerequisites">prerequisites section of the quick start</a>.</p>
<p>There are a few basic steps to integrate Sudograph into an existing project:</p>
<ul>
<li>Edit <code>dfx.json</code> in root directory</li>
<li>Add <code>Cargo.toml</code> to root directory</li>
<li>Create <code>graphql canister</code> crate</li>
<li>Create GraphQL schema</li>
<li>Import and call the <code>graphql_database</code> procedural macro</li>
<li>Create candid file</li>
<li>Deploy</li>
</ul>
<h2 id="edit-dfxjson-in-root-directory"><a class="header" href="#edit-dfxjson-in-root-directory">Edit dfx.json in root directory</a></h2>
<p>Add a new canister to your <code>dfx.json</code> in the root directory of your project. You can name the canister whatever you'd like, but to keep things simple we'll call the canister <code>graphql</code>. If you have other canisters already defined, just add the <code>graphql</code> canister. The canister defined below assumes a directory structure where there is a directory called <code>canisters</code> to contain each canister. You can change up the directory structure if you'd like, just change all of the paths appropriately.:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<h2 id="add-cargotoml-to-root-directory"><a class="header" href="#add-cargotoml-to-root-directory">Add Cargo.toml to root directory</a></h2>
<p>In the root directory of your project create a <code>Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml">[workspace]
members = [
    &quot;canisters/graphql&quot;,
]

[profile.release]
lto = true
opt-level = 'z'
</code></pre>
<p>Again this assumes your project has a <code>canisters</code> directory where the <code>graphql canister</code> will be defined. You can change the directory structure if you wish, just make sure to update this <code>Cargo.toml</code> file.</p>
<h2 id="create-graphql-canister-crate"><a class="header" href="#create-graphql-canister-crate">Create graphql canister crate</a></h2>
<p>Create a new directory within <code>canisters</code> called <code>graphql</code>, and add a <code>Cargo.toml</code> file. It should look like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;graphql&quot;
version = &quot;0.0.0&quot;
edition = &quot;2018&quot;

[lib]
path = &quot;src/graphql.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
sudograph = &quot;0.3.0&quot;
ic-cdk = &quot;0.3.0&quot; # TODO this will go away once https://github.com/dfinity/candid/pull/249 is released
</code></pre>
<p>Within the <code>canisters/graphql</code> directory, now create a <code>src</code> directory. The <code>canisters/graphql/src</code> directory will contain your GraphQL schema, the Rust entrypoint to your <code>graphql canister</code>, and your candid file.</p>
<h2 id="create-graphql-schema"><a class="header" href="#create-graphql-schema">Create GraphQL schema</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>schema.graphql</code> file. The following is just an example:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<h2 id="import-and-call-the-graphql_database-procedural-macro"><a class="header" href="#import-and-call-the-graphql_database-procedural-macro">Import and call the <code>graphql_database</code> procedural macro</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>graphql.rs</code> file. The file should look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This simply imports the <code>graphql_database</code> procedural macro from <code>sudograph</code> and then invokes it with the path to your <code>schema.graphql</code> file. This is where the magic happens and the database with CRUD queries and mutations are all generated.</p>
<h2 id="create-candid-file"><a class="header" href="#create-candid-file">Create candid file</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>graphql.did</code> file. The file should look like this:</p>
<pre><code>service : {
    &quot;graphql_query&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation&quot;: (text, text) -&gt; (text);
}
</code></pre>
<p>The generated canister code will have created the two functions defined in <code>graphql.did</code>, but for now you'll need to create the candid file manually. Hopefully in the future it can be generated for you or abstracted away somehow.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both take two parameters. The first parameter is the query or mutation string. The second parameter is a JSON string containing any variables for the query or mutation. Currently the second parameter is required, so just send an empty JSON object string <code>&quot;{}&quot;</code> if no variables are required for the query or mutation.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both return the result of the query or mutation as a JSON string. Whatever client is consuming the query or mutation will then need to parse the JSON string to turn it into a language-level object. The <a href="./sudograph-client.html">Sudograph Client</a> will do this for you in a JavaScript frontend.</p>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p>Use the following links for more information about <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h1 id="local-deployment"><a class="header" href="#local-deployment">Local deployment</a></h1>
<p>Start up an IC replica and deploy:</p>
<pre><code class="language-bash"># Open a terminal and run the following command to start a local IC replica
dfx start

# Alternatively to the above command, you can run the replica in the background
dfx start --background

# If you are running the replica in the background, you can run this command within the same terminal as the dfx start --background command
# If you are not running the replica in the background, then open another terminal and run this command from the root directory of your project
dfx deploy
</code></pre>
<p>Make sure to run <code>dfx deploy</code> for your first deploy. For quicker deployments after the first, you can run <code>dfx deploy graphql</code> if you've only changed your schema or the Rust code within the <code>graphql canister</code>. <code>dfx deploy graphql</code> will only deploy the <code>graphql canister</code>, which contains the generated database.</p>
<h2 id="playground-canister"><a class="header" href="#playground-canister">playground canister</a></h2>
<p>Start executing GraphQL queries and mutations against your database by going to the following URL in a Chromium browser: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a>.</p>
<h2 id="frontend-canister"><a class="header" href="#frontend-canister">frontend canister</a></h2>
<p>View a simple frontend application that communicates with the <code>graphql canister</code> by going to the following URL in a Chromium browser: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a>.</p>
<h2 id="command-line"><a class="header" href="#command-line">command line</a></h2>
<p>You can execute queries against the <code>graphql canister</code> from the command line if you wish:</p>
<pre><code class="language-bash"># send a query to the graphql canister
dfx canister call graphql graphql_query '(&quot;query { readUser { id } }&quot;, &quot;{}&quot;)'

# send a mutation to the graphql canister
dfx canister call graphql graphql_mutation '(&quot;mutation { createUser(input: { username: \&quot;lastmjs\&quot; }) { id } }&quot;, &quot;{}&quot;)'
</code></pre>
<h2 id="sudograph-client"><a class="header" href="#sudograph-client">Sudograph Client</a></h2>
<p>Still needs to be documented.</p>
<h2 id="rust-canister"><a class="header" href="#rust-canister">Rust canister</a></h2>
<p>If you want to call into the <code>graphql canister</code> from another Rust canister:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO fill out this example, show queries and mutations
<span class="boring">}
</span></code></pre></pre>
<h2 id="motoko-canister"><a class="header" href="#motoko-canister">Motoko canister</a></h2>
<p>If you want to call into the <code>graphql canister</code> from a Motoko canister:</p>
<pre><code class="language-swift">// TODO fill out this example, show queries and mutations
</code></pre>
<h2 id="wasm-binary-optimization"><a class="header" href="#wasm-binary-optimization">Wasm binary optimization</a></h2>
<p>If the replica rejects deployment of your canister because the payload is too large, you may need to <a href="./wasm-binary-optimization.html">optimize your Wasm binary</a>.</p>
<h1 id="ic-deployment"><a class="header" href="#ic-deployment">IC deployment</a></h1>
<p>Before deploying to the Internet Computer you should understand that Sudograph is alpha/beta software. There are missing features and potential bugs. There is also no way to easily migrate data (if you change your schema, you'll need to either delete your state and start over or manually make changes to the Sudograph data structures). But if you must deploy to the IC, here is the command:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<h2 id="wasm-binary-optimization-1"><a class="header" href="#wasm-binary-optimization-1">Wasm binary optimization</a></h2>
<p>If the replica rejects deployment of your canister because the payload is too large, you may need to <a href="./wasm-binary-optimization.html">optimize your Wasm binary</a>.</p>
<h1 id="wasm-binary-optimization-2"><a class="header" href="#wasm-binary-optimization-2">Wasm binary optimization</a></h1>
<p>At some point your compiled Rust Wasm binary will grow too large and will be rejected by the canister on deploy. This could happen because the Rust source code that you've written has grown too large, or because your schema has grown too large. A large schema will lead to a large amount of generated Rust code.</p>
<p>To temporarily overcome this issue (only so much can be done during optimization, eventually the binary will be too big and the Internet Computer will need to address that), you can optimize your Rust Wasm binary.</p>
<h3 id="manual-optimization"><a class="header" href="#manual-optimization">Manual optimization</a></h3>
<p>To do this manually, in the root of your directory run the following command once to install the optimizer:</p>
<pre><code class="language-bash">cargo install ic-cdk-optimizer --root target
</code></pre>
<p>You should also change your <code>dfx.json</code> file from:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<p>to:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;
        }
    }
}
</code></pre>
<p>The only thing that changed was the <code>wasm</code> property of the <code>graphql</code> canister object, and it changed from <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;</code> to <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;</code>.</p>
<p>Each time you run <code>dfx deploy</code> or <code>dfx deploy graphql</code>, you will need to run the following command after:</p>
<pre><code class="language-bash">./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimized.wasm
</code></pre>
<h3 id="automatic-optimization"><a class="header" href="#automatic-optimization">Automatic optimization</a></h3>
<p>It can be tedious to have to run the above command manually after each <code>dfx deploy</code>. If you wish to figure out how to use <code>cargo</code> scripts of some kind you can do that. You could also use <code>make</code> or <code>bash</code> or some other build process or scripting system.</p>
<p>Another way is to adopt npm scripts. Your <code>package.json</code> could look something like this:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;cd canisters/playground &amp;&amp; npm install &amp;&amp; npm run build &amp;&amp; cd ../frontend &amp;&amp; npm install &amp;&amp; npm run build&quot;,
        &quot;dfx-deploy&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy&quot;,
        &quot;dfx-deploy-graphql&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy graphql&quot;,
        &quot;dfx-build-graphql&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
        &quot;dfx-optimize-graphql&quot;: &quot;./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;
    }
}
</code></pre>
<p>Then instead of running <code>dfx deploy</code> or <code>dfx deploy graphql</code> you would run <code>npm run dfx-deploy</code> or <code>npm run dfx-deploy-graphql</code>.</p>
<p>In the future it would be nice for the <code>dfx.json</code> to allow for some sort of build scripts, which would make this process less messy. There is an open forum post about this <a href="https://forum.dfinity.org/t/dfx-json-build-scripts/4922">here</a></p>
<h1 id="sudograph-client-1"><a class="header" href="#sudograph-client-1">Sudograph Client</a></h1>
<p>The Sudograph Client is a frontend JavaScript/TypeScript library that provides a convenient API for interacting with your deployed <code>graphql canister</code>. It is an alternative to using <a href="./agent-js.html">agent-js</a> directly, and currently works only for the frontend (Node.js support will come later).</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Install Sudograph Client into your frontend project with <code>npm install sudograph</code>.</p>
<h2 id="use"><a class="header" href="#use">Use</a></h2>
<p>In addition to the code on this page, many of the <a href="./examples.html">examples</a> have frontend projects that show Sudograph Client in use.</p>
<p>For our example, let's imagine we have some sort of frontend UI component defined in a JavaScript file called <code>component.js</code>. You could import and prepare Sudograph Client for use as follows:</p>
<pre><code class="language-javascript">// component.js

import {
    gql,
    sudograph
} from 'sudograph';

const {
    query,
    mutation
} = sudograph({
    canisterId: 'ryjl3-tyaaa-aaaaa-aaaba-cai'
});
</code></pre>
<p>Above we import the <code>gql</code> tag and the <code>sudograph</code> function. The <code>gql</code> tag will be used for queries later on. To prepare for <code>query</code> or <code>mutation</code> execution, we call the <code>sudograph</code> function and pass in an options object. In this case, we simply put in the canister id of our <code>graphql canister</code>. The options object looks like this in TypeScript:</p>
<pre><code class="language-typescript">import { Identity } from '@dfinity/agent';

export type Options = Readonly&lt;{
    canisterId: string;
    identity?: Identity;
    queryFunctionName?: string;
    mutationFunctionName?: string;
}&gt;;
</code></pre>
<h2 id="query"><a class="header" href="#query">query</a></h2>
<p>If we want to execute a query, we would do so as follows. Imagine defining a function to return all user ids:</p>
<pre><code class="language-javascript">// component.js

async function getUserIds() {
    const result = await query(gql`
        query {
            readUser {
                id
            }
        }
    `);

    const users = result.data.readUser;

    return users;
}
</code></pre>
<p>By the way, the <code>gql</code> tag is just a nice way to integrate with existing editor tools, such as syntax highlighting and type checking. You can remove it if you'd like.</p>
<h2 id="mutation"><a class="header" href="#mutation">mutation</a></h2>
<p>If we want to execute a mutation, we would do so as follows. Imagine defining a function to create a user:</p>
<pre><code class="language-javascript">// component.js

async function createUser(username) {
    const result = await mutation(gql`
        mutation ($username: String!) {
            createUser(input: {
                username: $username
            }) {
                id
            }
        }
    `, {
        username
    });

    const user = result.data.createUser;

    return user;
}
</code></pre>
<h2 id="changing-query-and-mutation-canister-function-names"><a class="header" href="#changing-query-and-mutation-canister-function-names">Changing query and mutation canister function names</a></h2>
<p>The <code>queryFunctionName</code> and <code>mutationFunctionName</code> properties of the options object that we pass into the <code>sudograph</code> function allow us to specify the names of the canister functions that are exposed by our <code>graphql canister</code>. By default the generated query and mutation function names are <code>graphql_query</code> and <code>graphql_mutation</code>. Sudograph Client will assume those names should be used unless <code>queryFunctionName</code> and <code>mutationFunctionName</code> are supplied by the developer.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The <code>identity</code> property of the options object that we pass into the <code>sudograph</code> function helps us out with authentication, and its type is defined by <a href="https://github.com/dfinity/agent-js">@dfinity/agent</a>. If we pass in an <code>identity</code> object, it will be passed into the constructor of the <code>@dfinity/agent</code> <code>HttpAgent</code> that Sudograph Client is creating for you under the hood. This identity will be used to sign query and mutation requests, allowing you to implement authorization inside of your <code>graphql canister</code>.</p>
<p>The <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">files example</a> shows how to use Internet Identity with a <code>graphql canister</code>.</p>
<h1 id="agent-js"><a class="header" href="#agent-js">agent-js</a></h1>
<p>If you don't wish to use <a href="./sudograph-client.html">Sudograph Client</a>, you can reach for the lower-level <a href="https://github.com/dfinity/agent-js">agent-js</a> library.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Install <code>agent-js</code> into your frontend project with <code>npm install @dfinity/agent</code>.</p>
<h2 id="use-1"><a class="header" href="#use-1">Use</a></h2>
<p>In addition to the code on this page, <a href="https://github.com/sudograph/sudograph/blob/main/client/sudograph.ts">the Sudograph Client implementation</a> is a very good example of how to use <code>agent-js</code> directly to interact with a <code>graphql canister</code>.</p>
<p>For our example, let's imagine we have some sort of frontend UI component defined in a JavaScript file called <code>component.js</code>. You could import and prepare <code>agent-js</code> for use as follows:</p>
<pre><code class="language-javascript">// component.js

import {
    Actor,
    HttpAgent
} from '@dfinity/agent';

const idlFactory = ({ IDL }) =&gt; {
    return IDL.Service({
        graphql_query: IDL.Func([IDL.Text, IDL.Text], [IDL.Text], ['query']),
        graphql_mutation: IDL.Func([IDL.Text, IDL.Text], [IDL.Text], [])
    });
};

const agent = new HttpAgent();

const actor = Actor.createActor(idlFactory, {
    agent,
    canisterId: 'ryjl3-tyaaa-aaaaa-aaaba-cai'
});
</code></pre>
<p>Above we manually construct an <code>IDL Factory</code> describing the <code>graphql_query</code> and <code>graphql_mutation</code> functions exported from our canister. We then create an <code>agent</code> and use that agent with the canister id of our <code>graphql canister</code> to create an actor.</p>
<h2 id="query-1"><a class="header" href="#query-1">query</a></h2>
<p>If we want to execute a query, we would do so as follows. Imagine defining a function to return all user ids:</p>
<pre><code class="language-javascript">// component.js

async function getUserIds() {
    const result = await actor.graphql_query(`
        query {
            readUser {
                id
            }
        }
    `, JSON.stringify({}));

    const resultJSON = JSON.parse(result);

    const users = resultJSON.data.readUser;

    return users;
}
</code></pre>
<h2 id="mutation-1"><a class="header" href="#mutation-1">mutation</a></h2>
<p>If we want to execute a mutation, we would do so as follows. Imagine defining a function to create a user:</p>
<pre><code class="language-javascript">// component.js

async function createUser(username) {
    const result = await actor.graphql_mutation(`
        mutation ($username: String!) {
            createUser(input: {
                username: $username
            }) {
                id
            }
        }
    `, JSON.stringify({
        username
    }));

    const resultJSON = JSON.parse(result);

    const user = resultJSON.data.createUser;

    return user;
}
</code></pre>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<p>The <code>HttpAgent</code> from <code>@dfinity/agent</code> takes an object as a parameter to its contructor. That object has a property called <code>identity</code> of type <code>Identity</code> which can be found in <code>@dfinity/agent</code>. This identity will be used to sign requests made by the actor object that we create, allowing you to implement authorization inside of your <code>graphql canister</code>.</p>
<p>The <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">files example</a> shows how to use Internet Identity with a <code>graphql canister</code>.</p>
<h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>The schema is where you define all of the data types of your application, including relations between types. It is also where you will eventually define many other settings, possibly including authentication, authorization, subnet, and Sudograph-specific settings.</p>
<p>An example schema might look like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<p>We have told Sudograph that we have two object types, <code>User</code> and <code>BlogPost</code>. We've described the fields of each type, using some included scalar types such as <code>ID</code>, <code>Date</code>, and <code>String</code>. We have also described one relation between our two types, a one-to-many relationship from <code>User</code> to <code>BlogPost</code> on the fields <code>User:blogPosts</code> and <code>BlogPost:author</code>.</p>
<p>The schema is an incredibly powerful yet simple tool for defining the complex data types of your application. Get to know the possibilities of your schema:</p>
<ul>
<li><a href="./schema-scalars.html">Scalars</a></li>
<li><a href="./schema-objects.html">Objects</a></li>
<li><a href="./schema-relations.html">Relations</a></li>
<li><a href="./schema-custom-scalars.html">Custom scalars</a></li>
<li><a href="./schema-custom-resolvers.html">Custom resolvers</a></li>
<li><a href="./schema-custom-directives.html">Custom directives</a></li>
<li><a href="./schema-sudograph-directives.html">Sudograph directives</a></li>
<li><a href="./schema-sudograph-settings.html">Sudograph settings</a></li>
</ul>
<h1 id="scalars"><a class="header" href="#scalars">Scalars</a></h1>
<p>Scalar types are not divisible, they have no fields of their own. The scalar types automatically available to you in a Sudograph schema are:</p>
<ul>
<li><a href="schema-scalars.html#blob">Blob</a></li>
<li><a href="schema-scalars.html#boolean">Boolean</a></li>
<li><a href="schema-scalars.html#date">Date</a></li>
<li><a href="schema-scalars.html#float">Float</a></li>
<li><a href="schema-scalars.html#id">ID</a></li>
<li><a href="schema-scalars.html#int">Int</a></li>
<li><a href="schema-scalars.html#json">JSON</a></li>
<li><a href="schema-scalars.html#string">String</a></li>
</ul>
<h2 id="blob"><a class="header" href="#blob">Blob</a></h2>
<p>A <code>Blob</code> value maps to a Rust <code>Vec&lt;u8&gt;</code>.</p>
<pre><code class="language-graphql">type File {
    id: ID!
    contents: Blob!
}
</code></pre>
<p>Query or mutation inputs of type <code>Blob</code> should be strings or arrays of numbers that can be converted into Rust u8 numbers. <code>Blob</code> types in selection sets are always returned as JSON arrays of numbers.</p>
<p>An example in JavaScript of inputting a string for a <code>Blob</code>:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents
            }
        }
    `, {
        contents: 'hello'
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[104, 101, 108, 108, 111]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[104, 101, 108, 108, 111].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<p>An example in JavaScript of inputting an array of numbers for a <code>Blob</code>:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents
            }
        }
    `, {
        contents: 'hello'.split('').map(x =&gt; x.charCodeAt())
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[104, 101, 108, 108, 111]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[104, 101, 108, 108, 111].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<p><code>Blob</code> types in selection sets can use <code>offset</code> and <code>limit</code> to grab specific bytes:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents(offset: 1, limit: 3)
            }
        }
    `, {
        contents: 'hello'
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[101, 108, 108]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[101, 108, 108].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>A <code>Boolean</code> value maps to a Rust <code>bool</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    verified: Boolean!
}
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>A <code>Date</code> value maps to a Rust <code>String</code> for storage and a <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">chrono::DateTime</a> for filtering.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    dateOfBirth: Date!
}
</code></pre>
<p>Query or mutation inputs of type <code>Date</code> should be strings that can be parsed by <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">chrono::DateTime</a>. For example, in JavaScript <code>new Date().toISOString()</code> would be an acceptable format.</p>
<p>An example in JavaScript:</p>
<pre><code class="language-javascript">async function getUsersInInterval() {
    const result = await query(gql`
        query ($startDate: Date!, $endDate: Date!) {
            readUser(search: {
                dateOfBirth: {
                    gte: $startDate
                    lt: $endDate
                }
            }) {
                id
            }
        }
    `, {
        startDate: new Date('2021-07-01').toISOString(),
        endDate: new Date('2021-07-02').toISOString()
    });

    const users = result.data.readUser;

    return users;
}
</code></pre>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>A <code>Float</code> value maps to a Rust <code>f32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    height: Float!
}
</code></pre>
<h2 id="id"><a class="header" href="#id">ID</a></h2>
<p>An <code>ID</code> value maps to a Rust <code>String</code>. All Sudograph object types must have a field called <code>id</code> of type <code>ID</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>An <code>Int</code> value maps to a Rust <code>i32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    age: Int!
}
</code></pre>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>A <code>JSON</code> value maps to a Rust <code>String</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    meta: JSON!
}
</code></pre>
<p>Query or mutation inputs of type <code>JSON</code> should be any valid JSON value. <code>JSON</code> types in selection sets are always returned as JSON values.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>A <code>String</code> value maps to a Rust <code>String</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
}
</code></pre>
<h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Object types have fields that may be other object types or scalar types. Object types allow you to define the truly custom data types and relations that make up your application.</p>
<p>You could model a user with blog posts like so:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<p>You could model a family tree like so:</p>
<pre><code class="language-graphql"># TODO this example will not work yet
# TODO the self-referencing has some issues and multiple @relation directives per field is not yet supported
type Person {
    id: ID!
    firstName: String!
    lastName: String!
    father: Person @relation(name: &quot;Person:father::Person:children&quot;)
    mother: Person @relation(name: &quot;Person:mother::Person:children&quot;)
    children: [Person!]!
        @relation(name: &quot;Person:father::Person:children&quot;)
        @relation(name: &quot;Person:mother::Person:children&quot;)
}
</code></pre>
<p>You could model Ethereum block data like so:</p>
<pre><code class="language-graphql">type Block {
    id: ID!
    number: Int!
    hash: String!
    parent: Block
    transactionsRoot: String!
    transactionCount: Int!
    stateRoot: String!
    gasLimit: String!
    gasUsed: String!
    timestamp: Date!
    transactions: [Transaction!]! @relation(name: &quot;Block:transactions::Transaction:block&quot;)
}

type Transaction {
    id: ID!
    hash: String!
    index: Int!
    from: String!
    to: String!
    value: String!
    gasPrice: String!
    gas: String!
    inputData: String!
    block: Block! @relation(name: &quot;Block:transactions::Transaction:block&quot;)
    gasUsed: String!
}
</code></pre>
<h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>Relations allow you to describe the relationships between object types and their fields. Sudograph has a variety of relation capabilities.</p>
<p>Please note that the <code>name</code> argument of the <code>@relation</code> directive is just an arbitrary string, there is no DSL required. The only requirement is that the <code>name</code> argument be the same on both sides of the relation.</p>
<p>Also note that you can only have one <code>@relation</code> directive per field for now.</p>
<h2 id="one-to-one-relations"><a class="header" href="#one-to-one-relations">One-to-one relations</a></h2>
<p>One-to-one relations allow you to connect one object with another object.</p>
<h3 id="one-sided"><a class="header" href="#one-sided">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe
}

type Shoe {
    id: ID!
}
</code></pre>
<p>In the above example, you will be able to select the shoe of a foot, like so:</p>
<pre><code class="language-graphql">query {
    readFoot(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        shoe {
            id
        }
    }
}
</code></pre>
<p>You will not be able to select the foot of a shoe.</p>
<h3 id="two-sided"><a class="header" href="#two-sided">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}

type Shoe {
    id: ID!
    foot: Foot @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}
</code></pre>
<h2 id="one-to-many-relations"><a class="header" href="#one-to-many-relations">One-to-many relations</a></h2>
<p>One-to-many relations allow you to connect one object with multiple other objects.</p>
<h3 id="one-sided-1"><a class="header" href="#one-sided-1">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]!
}

type Banana {
    id: ID!
    color: String!
    size: Int!
}
</code></pre>
<p>In the above example, you will be able to select the bananas of a monkey, like so:</p>
<pre><code class="language-graphql">query {
    readMonkey(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        name
        bananas {
            id
            color
            size
        }
    }
}
</code></pre>
<p>You will not be able to select the monkey of a banana.</p>
<h3 id="two-sided-1"><a class="header" href="#two-sided-1">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]! @relation(name: &quot;Monkey:bananas::Banana:monkey&quot;)
}

type Banana {
    id: ID!
    color: String!
    size: Int!
    monkey: Monkey @relation(name: &quot;Monkey:bananas::Banana:monkey&quot;)
}
</code></pre>
<h2 id="many-to-many-relations"><a class="header" href="#many-to-many-relations">Many-to-many relations</a></h2>
<p>Many-to-many relations allow you to connect multiple objects with multiple other objects. Many-to-many relations must have a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Author {
    id: ID!
    documents: [Document!]! @relation(name: &quot;Author:documents::Document:authors&quot;)
}

type Document {
    id: ID!
    text: String!
    authors: [Author!]! @relation(name: &quot;Author:documents::Document:authors&quot;)
}
</code></pre>
<h1 id="custom-scalars"><a class="header" href="#custom-scalars">Custom scalars</a></h1>
<p>Custom scalars (scalars that you define) are not yet supported. You'll have to work with the included scalars:</p>
<ul>
<li><a href="./schema-scalars.html#blob">Blob</a></li>
<li><a href="./schema-scalars.html#boolean">Boolean</a></li>
<li><a href="./schema-scalars.html#date">Date</a></li>
<li><a href="./schema-scalars.html#float">Float</a></li>
<li><a href="./schema-scalars.html#id">ID</a></li>
<li><a href="./schema-scalars.html#int">Int</a></li>
<li><a href="./schema-scalars.html#json">JSON</a></li>
<li><a href="./schema-scalars.html#string">String</a></li>
</ul>
<h1 id="custom-resolvers"><a class="header" href="#custom-resolvers">Custom resolvers</a></h1>
<p>DISCLAIMER: Custom resolvers have only been minimally tested. Information presented here may not be entirely accurate. If you find issues please get in contact with <a href="https://twitter.com/lastmjs">@lastmjs</a> or open issues on the <a href="https://github.com/sudograph/sudograph">repository</a>.</p>
<p>Though Sudograph generates many powerful CRUD operations for you, it will not be able to cover every conceivable requirement of your applications. Custom resolvers provide a way for you to create your own functionality that is accessible through the same GraphQL API as Sudograph's generated functionality. There are two main locations a resolver can be written, within the <code>graphql canister</code> or in a separate canister.</p>
<h2 id="resolvers-within-the-graphql-canister"><a class="header" href="#resolvers-within-the-graphql-canister">Resolvers within the graphql canister</a></h2>
<p>You can see a full example of Rust custom resolvers <a href="https://github.com/sudograph/sudograph/tree/main/examples/rust-custom-resolvers">here</a>.</p>
<p>To write resolvers within your <code>graphql canister</code>, start by augmenting your schema, for example in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type Query {
    custom_get(id: ID!): Message
}

type Mutation {
    custom_set(id: ID!, text: String): Boolean!
}

type Message {
    id: ID!
    text: String!
}
</code></pre>
<p>We've added one custom query and one custom mutation to the schema. Next we need to implement the resolvers in code.</p>
<p>To implement a resolver, we add an asynchronous function to the Rust file that contains our <code>graphql_database</code> macro invocation. The function should have the same name as the query or mutation in the schema, and should use <a href="schema-custom-resolvers.html#type-conversions">parameter and return types</a> that match the types in the schema. The return type should be a <code>Result</code> with the <code>Ok</code> variant matching the return type in the schema, and you should use <code>sudograph::async_graphql::Error</code> as the <code>Err</code> variant. Object types generated from your schema are automatically in scope in Rust, because they are generated by the <code>graphql_database</code> macro.</p>
<p>Type conversions between GraphQL and Rust can be found <a href="schema-custom-resolvers.html#type-conversions">here</a>.</p>
<p>Now we'll implement the custom resolvers for the query and mutation in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

type PrimaryKey = String;
type MessageStore = HashMap&lt;PrimaryKey, Option&lt;Message&gt;&gt;;

async fn custom_get(id: ID) -&gt; Result&lt;Option&lt;Message&gt;, sudograph::async_graphql::Error&gt; {
    let message_store = sudograph::ic_cdk::storage::get::&lt;MessageStore&gt;();

    let message_option = message_store.get(&amp;id.to_string());

    match message_option {
        Some(message) =&gt; {
            return Ok(message.clone());
        },
        None =&gt; {
            return Ok(None);
        }
    };
}

async fn custom_set(id: ID, text: Option&lt;String&gt;) -&gt; Result&lt;bool, sudograph::async_graphql::Error&gt; {
    let message_store = sudograph::ic_cdk::storage::get_mut::&lt;MessageStore&gt;();

    let message = match text {
        Some(text_value) =&gt; Some(Message {
            id: id.clone(),
            text: text_value
        }),
        None =&gt; None
    };

    message_store.insert(id.to_string(), message);

    return Ok(true);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="resolvers-within-a-different-canister"><a class="header" href="#resolvers-within-a-different-canister">Resolvers within a different canister</a></h2>
<p>You can also write resolvers that are deployed to other canisters, using any language supported by the Internet Computer. For now you'll most likely be using Rust or Motoko, so examples are included below.</p>
<p>The process is similar to what you've just seen above, but in your GraphQL schema the custom queries and mutations have the addition of a <code>@canister</code> directive with the canister id of the canister that implements your resolver function.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>In a Rust canister, start by augmenting your schema, for example in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type Query {
    custom_get(id: ID!): Message @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Mutation {
    custom_set(id: ID!, text: String): Boolean! @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Message {
    id: ID!
    text: String!
}
</code></pre>
<p>Notice we've added <code>@canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)</code> to the custom query and mutation.</p>
<p>Now we need to implement the Rust canister. Let's imagine we've created another Rust canister in <code>canisters/another-rust-canister</code>. We might have a file called <code>canisters/another-rust-canister/src/lib.rs</code>, and it would look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph;

// TODO This hasn't been tested, might need some derive macros
struct ID(String);

impl ID {
    fn to_string(&amp;self) -&gt; String {
        return String::from(&amp;self.0);
    }
}

// TODO This hasn't been tested, might need some derive macros
struct Message {
    id: String,
    text: String
};

type PrimaryKey = String;
type MessageStore = HashMap&lt;PrimaryKey, Option&lt;Message&gt;&gt;;

#[sudograph::ic_cdk_macros::query]
async fn custom_get(id: ID) -&gt; Option&lt;Message&gt; {
    let message_store = sudograph::ic_cdk::storage::get::&lt;MessageStore&gt;();

    let message_option = message_store.get(&amp;id.to_string());

    match message_option {
        Some(message) =&gt; {
            return message.clone();
        },
        None =&gt; {
            return None;
        }
    };
}

#[sudograph::ic_cdk_macros::update]
async fn custom_set(id: ID, text: Option&lt;String&gt;) -&gt; bool {
    let message_store = sudograph::ic_cdk::storage::get_mut::&lt;MessageStore&gt;();

    let message = match text {
        Some(text_value) =&gt; Some(Message {
            id: id.clone(),
            text: text_value
        }),
        None =&gt; None
    };

    message_store.insert(id.to_string(), message);

    return true;
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice that these functions do not return a <code>Result</code>, they directly return the <a href="schema-custom-resolvers.html#type-conversions">Rust types that correspond to the GraphQL types</a>. This may change in the future as returning a <code>Result</code> may end up being more appropriate.</p>
<p>Also notice that we had to implement the <code>ID</code> and <code>Message</code> types ourselves. We do not have all of the generated types available because we are not using the <code>graphql_database</code> macro in this canister. In the future Sudograph may provide a simple way to generate these types for you without generating the entire database, but for now you'll have to implement them yourself or figure out an appropriate way to induce proper serialization and deserialization. For example, Candid might serialize and deserialize <code>ID</code> to and from strings for us...you'll just have to figure this out on your own for now.</p>
<h3 id="motoko"><a class="header" href="#motoko">Motoko</a></h3>
<p>You can see a full example of Motoko custom resolvers <a href="https://github.com/sudograph/sudograph/tree/main/examples/motoko-custom-resolvers">here</a>.</p>
<p>In a Motoko canister, start by augmenting your schema, for example in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type Query {
    customGet(id: ID!): Message @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Mutation {
    customSet(id: ID!, text: String): Boolean! @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Message {
    id: ID!
    text: String!
}
</code></pre>
<p>Notice we've added <code>@canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)</code> to the custom query and mutation.</p>
<p>Now we need to implement the Motoko canister. Let's imagine we've created a Motoko canister in <code>canisters/motoko</code>. We might have a file called <code>canisters/motoko/main.mo</code>, and it would look like this:</p>
<pre><code class="language-swift">import Text &quot;mo:base/Text&quot;;
import Map &quot;mo:base/HashMap&quot;;
import Option &quot;mo:base/Option&quot;;

actor Motoko {
    let message_store = Map.HashMap&lt;Text, ?Message&gt;(10, Text.equal, Text.hash);

    type Message = {
        id: Text;
        text: Text;
    };

    public query func customGet(id: Text): async ?Message {
        return Option.flatten(message_store.get(id));
    };

    public func customSet(id: Text, text: ?Text): async Bool {
        let message: ?Message = switch (text) {
            case null null;
            case (?text_value) Option.make({
                id;
                text = text_value;
            });
        };
        
        message_store.put(id, message);

        return true;
    };
}
</code></pre>
<p>Implementing the Motoko resolvers is very similar to implementing the Rust resolvers, the biggest difference besides the lanuage itself being the <a href="schema-custom-resolvers.html#type-conversions">type conversions</a>. We've implemented the <code>Message</code> type, and we've excluded the <code>ID</code> type and just used the native Motoko <code>Text</code> type. Again, you might have to experiment with the serialization and deserialization of values between canisters, a lot of it has to do with Candid.</p>
<h3 id="other-languages"><a class="header" href="#other-languages">Other languages</a></h3>
<p>Other languages are somewhat possible to use now (<code>C</code>, <code>C++</code>, <code>AssemblyScript</code>), and many more will come in the future as WebAssembly matures. Writing resolvers in each of these languages will be similar to writing them in Rust or Motoko. Once your schema is setup and correctly pointing to a canister, you simply implement the resolver in the language of choice and ensure that the types align correctly.</p>
<h2 id="type-conversions"><a class="header" href="#type-conversions">Type conversions</a></h2>
<h3 id="graphql---rust"><a class="header" href="#graphql---rust">GraphQL -&gt; Rust</a></h3>
<p><code>Object</code>, <code>ID</code>, and <code>Date</code> types must be created in Rust canisters if the <code>graphql_database</code> macro is not invoked. <code>ID</code> and <code>Date</code> types might work as <code>String</code> in Rust.</p>
<ul>
<li><code>Blob</code> -&gt; <code>Vec&lt;u8&gt;</code></li>
<li><code>Boolean</code> -&gt; <code>bool</code></li>
<li><code>Date</code> -&gt; <code>Date</code></li>
<li><code>Float</code> -&gt; <code>f32</code></li>
<li><code>ID</code> -&gt; <code>ID</code></li>
<li><code>Int</code> -&gt; <code>i32</code></li>
<li><code>JSON</code> -&gt; <code>serde_json::Value</code></li>
<li><code>String</code> -&gt; <code>String</code></li>
</ul>
<p>Creating a custom <code>ID</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO This hasn't been tested, might need some derive macros
struct ID(String);

impl ID {
    fn to_string(&amp;self) -&gt; String {
        return String::from(&amp;self.0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Creating a custom <code>Date</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO This hasn't been tested, might need some derive macros
struct Date(String);

impl Date {
    fn to_string(&amp;self) -&gt; String {
        return String::from(&amp;self.0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="graphql---motoko"><a class="header" href="#graphql---motoko">GraphQL -&gt; Motoko</a></h3>
<p>Object types must be manually created in Motoko.</p>
<ul>
<li><code>Blob</code> -&gt; <code>Blob</code></li>
<li><code>Boolean</code> -&gt; <code>Bool</code></li>
<li><code>Date</code> -&gt; <code>Text</code></li>
<li><code>Float</code> -&gt; <code>Float</code></li>
<li><code>ID</code> -&gt; <code>Text</code></li>
<li><code>Int</code> -&gt; <code>Int32</code></li>
<li><code>JSON</code> -&gt; <code>Text</code> (it's unclear if this will work)</li>
<li><code>String</code> -&gt; <code>Text</code></li>
</ul>
<h1 id="custom-directives"><a class="header" href="#custom-directives">Custom directives</a></h1>
<p>Custom directives (directives that you define) are not yet supported. You'll have to work with the <a href="./schema-sudograph-directives.html">Sudograph directives</a>.</p>
<h1 id="sudograph-directives"><a class="header" href="#sudograph-directives">Sudograph directives</a></h1>
<p>Sudograph provides a number of directives for use within your GraphQL schema. Directives can be applied to object types or fields within your schema. The following are available for use:</p>
<h2 id="relation"><a class="header" href="#relation">@relation</a></h2>
<ul>
<li>name: <code>relation</code></li>
<li>arguments: <code>name</code></li>
<li>application: <code>field</code></li>
<li>description: Indicates a two-sided relationship, where both sides of the relationship need to be updated during relation mutations. The <code>name</code> argument is an arbitrary string, but must be the same on both fields representing each side of the relationship.</li>
</ul>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}

type Shoe {
    id: ID!
    foot: Foot @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}
</code></pre>
<h2 id="canister"><a class="header" href="#canister">@canister</a></h2>
<ul>
<li>name: <code>canister</code></li>
<li>arguments: <code>id</code></li>
<li>application: <code>field</code></li>
<li>description: Indicates the canister with the implementation of the resolver function. The <code>id</code> argument is used to do a cross-canister function call under-the-hood.</li>
</ul>
<pre><code class="language-graphql">type Query {
    customGet(id: ID!): Message @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Mutation {
    customSet(id: ID!, text: String): Boolean! @canister(id: &quot;ryjl3-tyaaa-aaaaa-aaaba-cai&quot;)
}

type Message {
    id: ID!
    text: String!
}
</code></pre>
<h2 id="possible-future-relations"><a class="header" href="#possible-future-relations">Possible future relations</a></h2>
<p>Just let your imagination run wild with what some of these could do:</p>
<ul>
<li><code>@ignore</code></li>
<li><code>@auth</code></li>
<li><code>@token</code></li>
<li><code>@subnet</code></li>
</ul>
<h1 id="sudograph-settings"><a class="header" href="#sudograph-settings">Sudograph settings</a></h1>
<p>There will be many settings that Sudograph will allow the developer to customize. Sudograph settings are set in your GraphQL schema using the <code>SudographSettings</code> object type. The following are supported now:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedQueryFunction: true
    exportGeneratedMutationFunction: true
    exportGeneratedInitFunction: true
    exportGeneratedPostUpgradeFunction: true
}
</code></pre>
<h1 id="exportgeneratedqueryfunction"><a class="header" href="#exportgeneratedqueryfunction">exportGeneratedQueryFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>graphql_query</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic before executing a query, for example as part of an authorization flow.</p>
<p>Here's an example of overriding the generated <code>graphql_query</code> function with some basic authorization. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedQueryFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::query]
async fn graphql_query_custom(query_string: String, variables_json_string: String) -&gt; String {
    let authorized_principal = sudograph::ic_cdk::export::Principal::from_text(&quot;y6lgw-chi3g-2ok7i-75s5h-k34kj-ybcke-oq4nb-u4i7z-vclk4-hcpxa-hqe&quot;).expect(&quot;should be able to decode&quot;);
    
    if sudograph::ic_cdk::caller() != authorized_principal {
        panic!(&quot;Not authorized&quot;);
    }

    return graphql_query(query_string, variables_json_string).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>You would update <code>canisters/graphql/src/graphql.did</code>:</p>
<pre><code>service : {
    &quot;graphql_query_custom&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation&quot;: (text, text) -&gt; (text);
}
</code></pre>
<h1 id="exportgeneratedmutationfunction"><a class="header" href="#exportgeneratedmutationfunction">exportGeneratedMutationFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>graphql_mutation</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic before executing a mutation, for example as part of an authorization flow.</p>
<p>Here's an example of overriding the generated <code>graphql_mutation</code> function with some basic authorization. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedMutationFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::update]
async fn graphql_mutation_custom(mutation_string: String, variables_json_string: String) -&gt; String {
    let authorized_principal = sudograph::ic_cdk::export::Principal::from_text(&quot;y6lgw-chi3g-2ok7i-75s5h-k34kj-ybcke-oq4nb-u4i7z-vclk4-hcpxa-hqe&quot;).expect(&quot;should be able to decode&quot;);
    
    if sudograph::ic_cdk::caller() != authorized_principal {
        panic!(&quot;Not authorized&quot;);
    }

    return graphql_mutation(mutation_string, variables_json_string).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>You would update <code>canisters/graphql/src/graphql.did</code>:</p>
<pre><code>service : {
    &quot;graphql_query&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation_custom&quot;: (text, text) -&gt; (text);
}
</code></pre>
<h1 id="exportgeneratedinitfunction"><a class="header" href="#exportgeneratedinitfunction">exportGeneratedInitFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>init</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic during canister initialization. You'll want to make sure to call the generated <code>init</code> function after your functionality is complete, as it executes all of the <code>init</code> mutations that initialize the database.</p>
<p>Here's an example of overriding the generated <code>init</code> function. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedInitFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::init]
async fn init_custom() {
    init.await;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="exportgeneratedpostupgradefunction"><a class="header" href="#exportgeneratedpostupgradefunction">exportGeneratedPostUpgradeFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>post_upgrade</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic during canister post upgrade. You'll want to make sure to call the generated <code>post_upgrade</code> function after your functionality is complete, as it executes all of the <code>init</code> mutations that initialize the database (unless you are keeping your state through stable memory, then you would not want to initialize the database again).</p>
<p>Here's an example of overriding the generated <code>post_upgrade</code> function. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedPostUpgradeFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::post_upgrade]
async fn post_upgrade_custom() {
    post_upgrade.await;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="generated-schema"><a class="header" href="#generated-schema">Generated Schema</a></h1>
<p>Sudograph takes your <a href="./schema.html">schema</a> and generates a much more powerful schema along with the resolvers for that schema.</p>
<p>In addition to this documentation, assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<ul>
<li><a href="./generated-schema-query.html">Query</a>
<ul>
<li><a href="./generated-schema-query-read.html">read</a></li>
</ul>
</li>
<li><a href="./generated-schema-mutation.html">Mutation</a>
<ul>
<li><a href="./generated-schema-mutation-create.html">create</a></li>
<li><a href="./generated-schema-mutation-update.html">update</a></li>
<li><a href="./generated-schema-mutation-delete.html">delete</a></li>
</ul>
</li>
<li><a href="./generated-schema-subscription.html">Subscription</a></li>
<li><a href="./generated-schema-search.html">Search</a></li>
<li><a href="./generated-schema-limit.html">Limit</a></li>
<li><a href="./generated-schema-offset.html">Offset</a></li>
<li><a href="./generated-schema-order.html">Order</a></li>
</ul>
<p>As an example, given the following simple schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}

type BlogPost {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following schema along with its resolvers:</p>
<pre><code class="language-graphql">type Query {
  readUser(
    search: ReadUserInput,
    limit: Int,
    offset: Int,
    order: OrderUserInput
  ): [User!]!
	
  readBlogPost(
    search: ReadBlogPostInput,
    limit: Int,
    offset: Int,
    order: OrderBlogPostInput
  ): [BlogPost!]!
}

input DeleteUserInput {
	id: ID
	ids: [ID!]
}

input UpdateBlogPostInput {
	id: ID!
}

input DeleteBlogPostInput {
	id: ID
	ids: [ID!]
}

input ReadUserInput {
	id: ReadIDInput
	and: [ReadUserInput!]
	or: [ReadUserInput!]
}

input ReadIDInput {
	eq: ID
	gt: ID
	gte: ID
	lt: ID
	lte: ID
	contains: ID
}

input OrderUserInput {
	id: OrderDirection
}

enum OrderDirection {
	ASC
	DESC
}

type User {
	id: ID!
}

input ReadBlogPostInput {
	id: ReadIDInput
	and: [ReadBlogPostInput!]
	or: [ReadBlogPostInput!]
}

input OrderBlogPostInput {
	id: OrderDirection
}

type BlogPost {
	id: ID!
}

type Mutation {
	createUser(input: CreateUserInput): [User!]!
	createBlogPost(input: CreateBlogPostInput): [BlogPost!]!
	updateUser(input: UpdateUserInput!): [User!]!
	updateBlogPost(input: UpdateBlogPostInput!): [BlogPost!]!
	deleteUser(input: DeleteUserInput!): [User!]!
	deleteBlogPost(input: DeleteBlogPostInput!): [BlogPost!]!
	initUser: Boolean!
	initBlogPost: Boolean!
}

input UpdateUserInput {
	id: ID!
}

input CreateBlogPostInput {
	id: ID
}

input CreateUserInput {
	id: ID
}
</code></pre>
<h1 id="query-2"><a class="header" href="#query-2">Query</a></h1>
<p>Sudograph will generate the equivalent of the <code>Query</code> object type based on your GraphQL schema. If you have specified your own <code>Query</code> object type, the two object types will be combined into the final <code>Query</code> object type.</p>
<p>The fields in the <code>Query</code> object type generated by Sudograph are:</p>
<ul>
<li><a href="./generated-schema-query-read.html">read</a></li>
</ul>
<h1 id="read"><a class="header" href="#read">read</a></h1>
<p>The <code>read</code> query is the main way to read data from your GraphQL database.</p>
<p>Per object type defined in your GraphQL schema, Sudograph generates one <code>read</code> field on the <code>Query</code> object type. We'll focus in on what happens with one object type defined. Imagine your schema looks like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following (we're focusing on just one part of the generated schema):</p>
<pre><code class="language-graphql">type Query {
    readUser(
        search: ReadUserInput,
        limit: Int
        offset: Int
        order: OrderUserInput
    ): [User!]!
}

input ReadUserInput {
	id: ReadIDInput
	and: [ReadUserInput!]
	or: [ReadUserInput!]
}

input OrderUserInput {
	id: OrderDirection
}

enum OrderDirection {
	ASC
	DESC
}
</code></pre>
<p>Each <code>read</code> query has the ability to <a href="./generated-schema-search.html">search</a>, <a href="./generated-schema-limit.html">limit</a>, <a href="./generated-schema-offset.html">offset</a>, and <a href="./generated-schema-order.html">order</a>. Each <code>read</code> query returns an array of its corresponding object types.</p>
<p>It's important to remember that within <code>read</code> selection sets you also have the ability to <a href="./generated-schema-search.html">search</a>, <a href="./generated-schema-limit.html">limit</a>, <a href="./generated-schema-offset.html">offset</a>, and <a href="./generated-schema-order.html">order</a> on any <code>many-relation</code>.</p>
<p>For example if you had this schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    blogPosts: [BlogPost!]!
}

type BlogPost {
    id: ID!
    title: String!
}
</code></pre>
<p>You could write a query like this:</p>
<pre><code class="language-graphql">query {
    readUser {
        id
        blogPosts(
            search: {
                title: {
                    contains: &quot;The&quot;
                }
            }
            offset: 0
            limit: 10
            order: {
                title: ASC
            }
        ) {
            id
            title
        }
    }
}
</code></pre>
<h1 id="mutation-2"><a class="header" href="#mutation-2">Mutation</a></h1>
<p>Sudograph will generate the equivalent of the <code>Mutation</code> object type based on your GraphQL schema. If you have specified your own <code>Mutation</code> object type, the two object types will be combined into the final <code>Mutation</code> object type.</p>
<p>The fields in the <code>Mutation</code> object type generated by Sudograph are:</p>
<ul>
<li><a href="./generated-schema-mutation-create.html">create</a></li>
<li><a href="./generated-schema-mutation-update.html">update</a></li>
<li><a href="./generated-schema-mutation-delete.html">delete</a></li>
<li><a href="./generated-schema-mutation-init.html">init</a></li>
</ul>
<h1 id="create"><a class="header" href="#create">create</a></h1>
<p>The <code>create</code> mutation is the main way to create data in your GraphQL database.</p>
<p>Per object type defined in your GraphQL schema, Sudograph generates one <code>create</code> field on the <code>Mutation</code> object type. We'll focus in on what happens with one object type defined. Imagine your schema looks like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following (we're focusing on just one part of the generated schema):</p>
<pre><code class="language-graphql">type Mutation {
	createUser(input: CreateUserInput): [User!]!
}

input CreateUserInput {
	id: ID
}
</code></pre>
<p>It's important to remember that within <code>create</code> selection sets you also have the ability to <a href="./generated-schema-search.html">search</a>, <a href="./generated-schema-limit.html">limit</a>, <a href="./generated-schema-offset.html">offset</a>, and <a href="./generated-schema-order.html">order</a> on any <code>many-relation</code>.</p>
<p>For example if you had this schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    blogPosts: [BlogPost!]!
}

type BlogPost {
    id: ID!
    title: String!
}
</code></pre>
<p>You could write a query like this:</p>
<pre><code class="language-graphql">mutation {
    createUser(blogPosts: {
        connect: [&quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;]
    }) {
        id
        blogPosts(
            search: {
                title: {
                    contains: &quot;The&quot;
                }
            }
            offset: 0
            limit: 10
            order: {
                title: ASC
            }
        ) {
            id
            title
        }
    }
}
</code></pre>
<h1 id="update"><a class="header" href="#update">update</a></h1>
<p>The <code>update</code> mutation is the main way to update data in your GraphQL database.</p>
<p>Per object type defined in your GraphQL schema, Sudograph generates one <code>update</code> field on the <code>Mutation</code> object type. We'll focus in on what happens with one object type defined. Imagine your schema looks like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following (we're focusing on just one part of the generated schema):</p>
<pre><code class="language-graphql">type Mutation {
	updateUser(input: UpdateUserInput!): [User!]!
}

input UpdateUserInput {
	id: ID!
}
</code></pre>
<p>It's important to remember that within <code>update</code> selection sets you also have the ability to <a href="./generated-schema-search.html">search</a>, <a href="./generated-schema-limit.html">limit</a>, <a href="./generated-schema-offset.html">offset</a>, and <a href="./generated-schema-order.html">order</a> on any <code>many-relation</code>.</p>
<p>For example if you had this schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    blogPosts: [BlogPost!]!
}

type BlogPost {
    id: ID!
    title: String!
}
</code></pre>
<p>You could write a query like this:</p>
<pre><code class="language-graphql">mutation {
    updateUser(
        id: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        blogPosts: {
            connect: [&quot;2c3nrr-4jhf3-2gozt-hj37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;]
        }
    ) {
        id
        blogPosts(
            search: {
                title: {
                    contains: &quot;The&quot;
                }
            }
            offset: 0
            limit: 10
            order: {
                title: ASC
            }
        ) {
            id
            title
        }
    }
}
</code></pre>
<h1 id="delete"><a class="header" href="#delete">delete</a></h1>
<p>The <code>delete</code> mutation is the main way to delete data in your GraphQL database.</p>
<p>Per object type defined in your GraphQL schema, Sudograph generates one <code>delete</code> field on the <code>Mutation</code> object type. We'll focus in on what happens with one object type defined. Imagine your schema looks like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following (we're focusing on just one part of the generated schema):</p>
<pre><code class="language-graphql">type Mutation {
	deleteUser(input: DeleteUserInput!): [User!]!
}

input DeleteUserInput {
	id: ID
	ids: [ID!]
}
</code></pre>
<p>It's important to remember that within <code>delete</code> selection sets you also have the ability to <a href="./generated-schema-search.html">search</a>, <a href="./generated-schema-limit.html">limit</a>, <a href="./generated-schema-offset.html">offset</a>, and <a href="./generated-schema-order.html">order</a> on any <code>many-relation</code>.</p>
<p>For example if you had this schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    blogPosts: [BlogPost!]!
}

type BlogPost {
    id: ID!
    title: String!
}
</code></pre>
<p>You could write a query like this:</p>
<pre><code class="language-graphql">mutation {
    deleteUser(input: {
        id: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
    }) {
        id
        blogPosts(
            search: {
                title: {
                    contains: &quot;The&quot;
                }
            }
            offset: 0
            limit: 10
            order: {
                title: ASC
            }
        ) {
            id
            title
        }
    }
}
</code></pre>
<h1 id="init"><a class="header" href="#init">init</a></h1>
<p>The <code>init</code> mutation initializes the underlying Rust data structures in your GraphQL database. This mutation must be run before other queries or mutations can be executed for an object type. Sudograph will automatically run all <code>init</code> mutations for all of your object types in the <code>graphql canister</code>'s <code>init</code> and <code>post_upgrade</code> functions, unless you override them.</p>
<p>Per object type defined in your GraphQL schema, Sudograph generates one <code>init</code> field on the <code>Mutation</code> object type. We'll focus in on what happens with one object type defined. Imagine your schema looks like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Sudograph will generate the following (we're focusing on just one part of the generated schema):</p>
<pre><code class="language-graphql">type Mutation {
	initUser: Boolean!
}
</code></pre>
<h1 id="subscription"><a class="header" href="#subscription">Subscription</a></h1>
<p>Subscriptions are not currently supported by Sudograph.</p>
<p>Because the Internet Computer itself does not have any push mechanisms exposed, it will be difficult to provide subscription capabilities in the normal ways e.g. web sockets.</p>
<p>For now you will have to implement your own polling solutions to know when data has been updated.</p>
<h1 id="search"><a class="header" href="#search">Search</a></h1>
<p>The <code>search</code> input allows for flexible querying of records. You can query by <a href="generated-schema-search.html#scalar-search">scalars</a> and <a href="generated-schema-search.html#relation-search">relations</a> to arbitrary depths (assuming performance allows). You can also use arbitrary combinations of <a href="generated-schema-search.html#and">and</a> and <a href="generated-schema-search.html#or">or</a> in your searches.</p>
<h2 id="scalar-search"><a class="header" href="#scalar-search">Scalar search</a></h2>
<p>You can search by scalar fields using the inputs generated for each scalar type.</p>
<h3 id="blob-1"><a class="header" href="#blob-1">Blob</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadBlobInput {
	eq: Blob
	contains: Blob
	startsWith: Blob
	endsWith: Blob
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readFile(search: {
        contents: {
            eq: [101, 108, 108]
        }
    }) {
        id
        contents
    }
}

query {
    readFile(search: {
        contents: {
            contains: [108, 108]
        }
    }) {
        id
        contents
    }
}

query {
    readFile(search: {
        contents: {
            startsWith: [101]
        }
    }) {
        id
        contents
    }
}

query {
    readFile(search: {
        contents: {
            endsWith: [108]
        }
    }) {
        id
        contents
    }
}
</code></pre>
<h3 id="boolean-1"><a class="header" href="#boolean-1">Boolean</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadBooleanInput {
	eq: Boolean
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        living: {
            eq: true
        }
    }) {
        id
        living
    }
}
</code></pre>
<h3 id="date-1"><a class="header" href="#date-1">Date</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadDateInput {
	eq: Date
	gt: Date
	gte: Date
	lt: Date
	lte: Date
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readBlogPost(search: {
        createdAt: {
            eq: &quot;2021-07-02T22:45:44.001Z&quot;
        }
    }) {
        id
        title
    }
}

query {
    readBlogPost(search: {
        createdAt: {
            gt: &quot;2021-07-02T22:45:44.001Z&quot;
        }
    }) {
        id
        title
    }
}

query {
    readBlogPost(search: {
        createdAt: {
            gte: &quot;2021-07-02T22:45:44.001Z&quot;
        }
    }) {
        id
        title
    }
}

query {
    readBlogPost(search: {
        createdAt: {
            lt: &quot;2021-07-02T22:45:44.001Z&quot;
        }
    }) {
        id
        title
    }
}

query {
    readBlogPost(search: {
        createdAt: {
            lte: &quot;2021-07-02T22:45:44.001Z&quot;
        }
    }) {
        id
        title
    }
}
</code></pre>
<h3 id="float-1"><a class="header" href="#float-1">Float</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadFloatInput {
	eq: Float
	gt: Float
	gte: Float
	lt: Float
	lte: Float
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        height: {
            eq: 5.8
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        height: {
            gt: 5.8
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        height: {
            gte: 5.8
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        height: {
            lt: 5.8
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        height: {
            lte: 5.8
        }
    }) {
        id
    }
}
</code></pre>
<h3 id="id-1"><a class="header" href="#id-1">ID</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadIDInput {
	eq: ID
	gt: ID
	gte: ID
	lt: ID
	lte: ID
	contains: ID
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        id: {
            gt: &quot;1&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        id: {
            gte: &quot;1&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        id: {
            lt: &quot;100&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        id: {
            lte: &quot;100&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        id: {
            contains: &quot;7c3nrr&quot;
        }
    }) {
        id
    }
}
</code></pre>
<h3 id="int-1"><a class="header" href="#int-1">Int</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadIntInput {
	eq: Int
	gt: Int
	gte: Int
	lt: Int
	lte: Int
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        age: {
            eq: 25
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        age: {
            gt: 20
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        age: {
            gte: 30
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        age: {
            lt: 45
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        age: {
            lte: 70
        }
    }) {
        id
    }
}
</code></pre>
<h3 id="json-1"><a class="header" href="#json-1">JSON</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadJSONInput {
	eq: String
	gt: String
	gte: String
	lt: String
	lte: String
	contains: String
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        meta: {
            eq: &quot;{ \&quot;zone\&quot;: 5 }&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        meta: {
            gt: &quot;{ \&quot;zone\&quot;: 5 }&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        meta: {
            gte: &quot;{ \&quot;zone\&quot;: 5 }&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        meta: {
            lt: &quot;{ \&quot;zone\&quot;: 5 }&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        meta: {
            lte: &quot;{ \&quot;zone\&quot;: 5 }&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        meta: {
            contains: &quot;zone&quot;
        }
    }) {
        id
    }
}
</code></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p>Generated input:</p>
<pre><code class="language-graphql">input ReadStringInput {
    eq: String
	gt: String
	gte: String
	lt: String
	lte: String
	contains: String
}
</code></pre>
<p>Examples:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        username: {
            eq: &quot;lastmjs&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        username: {
            gt: &quot;lastmjs&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        username: {
            gte: &quot;lastmjs&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        username: {
            lt: &quot;lastmjs&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        username: {
            lte: &quot;lastmjs&quot;
        }
    }) {
        id
    }
}

query {
    readUser(search: {
        username: {
            contains: &quot;mjs&quot;
        }
    }) {
        id
    }
}
</code></pre>
<h2 id="and"><a class="header" href="#and">and</a></h2>
<p>The search input for each object type, in addition to all scalar and relation fields, contains an <code>and</code> field. If you want to <code>and</code> together multiple searches of the same field, there are two ways to do so:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        age: {
            gte: 5
            lte: 10
        }
    }) {
        id
        age
    }
}
</code></pre>
<p>This can also be achieved like so:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        and: [
            {
                age: {
                    gte: 5
                }
            },
            {
                age: {
                    lte: 10
                }
            }
        ]
    }) {
        id
        age
    }
}
</code></pre>
<h2 id="or"><a class="header" href="#or">or</a></h2>
<p>The search input for each object type, in addition to all scalar and relation fields, contains an <code>or</code> field. If you want to <code>or</code> together multiple searches of the same field, you can do so:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        or: [
            {
                age: {
                    eq: 5
                }
            },
            {
                age: {
                    eq: 6
                }
            }
        ]
    }) {
        id
        age
    }
}
</code></pre>
<h2 id="relation-search"><a class="header" href="#relation-search">Relation search</a></h2>
<p>You can search by relation fields using the search inputs generated for each object type.</p>
<p>Imagine the following schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<p>The search inputs generated for each object type would be:</p>
<pre><code class="language-graphql">input ReadUserInput {
	id: ReadIDInput
	username: ReadStringInput
	blogPosts: ReadBlogPostInput
	and: [ReadUserInput!]
	or: [ReadUserInput!]
}

input ReadBlogPostInput {
	id: ReadIDInput
	publishedAt: ReadDateInput
	title: ReadStringInput
	author: ReadUserInput
	and: [ReadBlogPostInput!]
	or: [ReadBlogPostInput!]
}
</code></pre>
<p>You can search across relations like so:</p>
<pre><code class="language-graphql">query {
    readUser(search: {
        blogPosts: {
            title: {
                contains: &quot;The&quot;
            }
        }
    }) {
        id
        username
        blogPosts {
            id
            title
        }
    }
}
</code></pre>
<h1 id="limit"><a class="header" href="#limit">Limit</a></h1>
<p>The <code>limit</code> input argument is an <code>Int</code> that allows you to specify how many records to return for a selection. For example, a <code>limit</code> of 0 would always return 0 records, and a <code>limit</code> of 10 would return no more than 10 records.</p>
<p>If the <code>limit</code> specified is greater than the number of records available based on the query inputs, then the total number of records available will be returned.</p>
<p>Combining <code>limit</code> with <a href="./generated-schema-offset.html">offset</a> allows for flexible paging capabilities. A good example of paging can be found in the <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">frontend of the files example</a>.</p>
<p>Assuming there are 10 <code>User</code> records in the database:</p>
<pre><code class="language-graphql">query {
    readUser(limit: 10) {
        id
    }
}

# The readUser property in the selection set would be:
# [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }, { id: 6 }, { id: 7 }, { id: 8 }, { id: 9 }]
</code></pre>
<pre><code class="language-graphql">query {
    readUser(limit: 5) {
        id
    }
}

# The readUser property in the selection set would be:
# [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }]
</code></pre>
<pre><code class="language-graphql">query {
    readUser(limit: 0) {
        id
    }
}

# The readUser property in the selection set would be:
# []
</code></pre>
<p>It's important to remember that within any selection sets you have the ability to limit on any <code>many-relation</code>:</p>
<pre><code class="language-graphql">query {
    readUser {
        id
        blogPosts(limit: 5) {
            title
        }
    }
}

mutation {
    createUser(input: {
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(limit: 5) {
            title
        }
    }
}

mutation {
    updateUser(input: {
        id: &quot;0&quot;
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(limit: 5) {
            title
        }
    }
}

mutation {
    deleteUser(input: {
        id: &quot;0&quot;
    }) {
        id
        blogPosts(limit: 5) {
            title
        }
    }
}
</code></pre>
<h1 id="offset"><a class="header" href="#offset">Offset</a></h1>
<p>The <code>offset</code> input argument is an <code>Int</code> that allows you to specify the starting index in the selection of records. For example, imagine there are 10 <code>User</code> records in the database. An <code>offset</code> of 0 would return all 10 records starting at index 0 which is the first record (assuming they are ordered already in the database):</p>
<pre><code class="language-graphql">query {
    readUser(offset: 0) {
        id
    }
}

# The readUser property in the selection set would be:
# [{ id: 0 }, { id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }, { id: 6 }, { id: 7 }, { id: 8 }, { id: 9 }]
</code></pre>
<p>An <code>offset</code> of 1 would return 9 records starting at index 1 which is the second record:</p>
<pre><code class="language-graphql">query {
    readUser(offset: 1) {
        id
    }
}

# The readUser property in the selection set would be:
# [{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }, { id: 6 }, { id: 7 }, { id: 8 }, { id: 9 }]
</code></pre>
<p>If the <code>offset</code> specified is greater than or equal to the number of records available based on the query inputs, Sudograph will panic causing the call to trap. Essentially at this point the offset has gone beyond the end of the selection array. If you disagree with this choice let me know <a href="https://twitter.com/lastmjs">@lastmjs</a> or open an issue in the <a href="https://github.com/sudograph/sudograph">repository</a>.</p>
<p>Combining <code>offset</code> with <a href="./generated-schema-limit.html">limit</a> allows for flexible paging capabilities. A good example of paging can be found in the <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">frontend of the files example</a>.</p>
<p>It's important to remember that within any selection sets you have the ability to offset on any <code>many-relation</code>:</p>
<pre><code class="language-graphql">query {
    readUser {
        id
        blogPosts(offset: 5) {
            title
        }
    }
}

mutation {
    createUser(input: {
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(offset: 5) {
            title
        }
    }
}

mutation {
    updateUser(input: {
        id: &quot;0&quot;
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(offset: 5) {
            title
        }
    }
}

mutation {
    deleteUser(input: {
        id: &quot;0&quot;
    }) {
        id
        blogPosts(offset: 5) {
            title
        }
    }
}
</code></pre>
<h1 id="order"><a class="header" href="#order">Order</a></h1>
<p>The <code>order</code> input allows you to order by any one scalar field of an object type. In the future it may be possible to order by multiple fields. There are two possible orderings, <code>DESC</code> and <code>ASC</code>.</p>
<p>Here are some examples assuming the following schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    age: Int!
    username: String!
}
</code></pre>
<pre><code class="language-graphql">query {
    readUser(order: {
        id: DESC
    }) {
        id
    }
}

query {
    readUser(order: {
        age: ASC
    }) {
        id
    }
}

query {
    readUser(order: {
        username: DESC
    }) {
        id
    }
}
</code></pre>
<p>It's important to remember that within any selection sets you have the ability to order on any <code>many-relation</code>:</p>
<pre><code class="language-graphql">query {
    readUser {
        id
        blogPosts(order: {
            title: DESC
        }) {
            title
        }
    }
}

mutation {
    createUser(input: {
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(order: {
            title: DESC
        }) {
            title
        }
    }
}

mutation {
    updateUser(input: {
        id: &quot;0&quot;
        username: &quot;lastmjs&quot;
    }) {
        id
        blogPosts(order: {
            title: DESC
        }) {
            title
        }
    }
}

mutation {
    deleteUser(input: {
        id: &quot;0&quot;
    }) {
        id
        blogPosts(order: {
            title: DESC
        }) {
            title
        }
    }
}
</code></pre>
<h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<h1 id="migrations"><a class="header" href="#migrations">Migrations</a></h1>
<p>Whenever you wish to make changes to a canister without losing that canister's state, you must perform what is called an <a href="https://sdk.dfinity.org/docs/developers-guide/working-with-canisters.html#upgrade-canister">upgrade</a>.</p>
<p>An <code>upgrade</code> allows you to preserve your canister's state while changing its code. You can see a full example of an upgrade <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/graphql/src/graphql.rs">here</a>.</p>
<h2 id="simple-migrations"><a class="header" href="#simple-migrations">Simple migrations</a></h2>
<p>If you haven't changed your schema and you just want to preserve state across upgrades:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph;

sudograph::graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::pre_upgrade]
fn pre_upgrade_custom() {
    let object_type_store = sudograph::ic_cdk::storage::get::&lt;ObjectTypeStore&gt;();

    sudograph::ic_cdk::storage::stable_save((object_type_store,));
}

#[sudograph::ic_cdk_macros::post_upgrade]
fn post_upgrade_custom() {
    let (stable_object_type_store,): (ObjectTypeStore,) = sudograph::ic_cdk::storage::stable_restore().expect(&quot;ObjectTypeStore should be in stable memory&quot;);

    let object_type_store = sudograph::ic_cdk::storage::get_mut::&lt;ObjectTypeStore&gt;();

    for (key, value) in stable_object_type_store.into_iter() {
        object_type_store.insert(key, value);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>upgrade</code> shown above assumes no changes to your GraphQL schema. If you were to change your GraphQL schema and then perform the <code>upgrade</code>, you would run into a number of issues. This is because the <a href="./custom-database-operations.html#objecttypestore">underlying data structures</a> that make up your database would be out of sync with your schema. In this case your code would cease to function as intended.</p>
<p>You must perform automatic or manual migrations on your code if you change your schema.</p>
<h2 id="automatic-migrations"><a class="header" href="#automatic-migrations">Automatic migrations</a></h2>
<p>Automatic migrations are not currently supported. For now you'll need to manually change the <code>ObjectTypeStore</code> in your <code>post_upgrade</code> function to reflect the changes in your schema, or accept that you will lose all of your state on every deploy (this may be acceptable if you plan on only deploying once).</p>
<p>The plan is to eventually automate migrations as much as possible. If you change your schema and wish to update it on a live canister, Sudograph will generate migrations written in Rust to accomplish the migration for you. If a migration cannot be performed automatically, Sudograph will allow you to easily define your own migration code in Rust. That's the rough plan for now.</p>
<h2 id="manual-migrations"><a class="header" href="#manual-migrations">Manual migrations</a></h2>
<p>Even with automatic migrations, you will run into scenarios that cannot be handled automatically. You may be required to manually update the <code>ObjectTypeStore</code> in the <code>post_upgrade</code> function to fully migrate data after schema changes. Studying <a href="./custom-database-operations.html#objecttypestore">the documentation available for the ObjectTypeStore</a> will help you determine what needs to be changed within it when you change your schema.</p>
<p>Let's look at the migrations required when we add a field to an object type in our schema. Here's the original schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<p>Imagine that we have deployed the original schema. Now we will change the schema:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String
}
</code></pre>
<p>We need to change the <code>ObjectTypeStore</code> so that it is aware of the change. In our <code>post_upgrade</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sudograph::ic_cdk_macros::post_upgrade]
fn post_upgrade_custom() {
    let (stable_object_type_store,): (ObjectTypeStore,) = sudograph::ic_cdk::storage::stable_restore().expect(&quot;ObjectTypeStore should be in stable memory&quot;);

    let object_type_store = sudograph::ic_cdk::storage::get_mut::&lt;ObjectTypeStore&gt;();

    for (key, value) in stable_object_type_store.into_iter() {
        object_type_store.insert(key, value);
    }

    // First grab the object type for User
    let user_object_type = object_type_store.get_mut(&quot;User&quot;).expect(&quot;User object type should exist&quot;);

    // Then add the type information for the username field
    user_object_type.field_types_store.insert(
        &quot;username&quot;.to_string(),
        sudograph::sudodb::FieldType::String
    );

    // Finally add the initial values for the username field
    for field_value_store in user_object_type.field_values_store.values_mut() {
        field_value_store.insert(
            &quot;username&quot;.to_string(),
            sudograph::sudodb::FieldValue::Scalar(None)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After the next deploy we will have successfully migrated our database! Make sure to remove the code on subsequent deploys. Automatic migrations will make this process simpler and more standardized.</p>
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>Sudograph does not have a strong guarantee of atomicity (transactions) at this time. Read on for more information.</p>
<h2 id="single-canister-mutations"><a class="header" href="#single-canister-mutations">Single canister mutations</a></h2>
<p>Within a single update call, transactions are automatically handled by the Internet Computer itself! If there are any errors (technically Wasm traps) all state changes are undone and thus not persisted. This is a very nice feature of single canister development, and it's important to know that the schema that Sudograph generates for you is limited to a single canister by default.</p>
<p>Unfortunately, Sudograph does not currently guarantee that all errors will lead to traps, and thus there is no guarantee that all state changes within a single update call will be undone. Once an automated testing framework is in place, adding this functionality to Sudograph should not be too difficult.</p>
<p>Once Sudograph ensures all errors will lead to traps, you will be able to execute transactions and ensure atomicity by executing many mutations within a single update call like this:</p>
<pre><code class="language-graphql">mutation {
    createUser1: createUser(input: {
        username: &quot;user1&quot;
    }) {
        id
    }

    createUser2: createUser(input: {
        username: &quot;user2&quot;
    }) {
        id
    }

    createUser3: createUser(input: {
        username: &quot;user3&quot;
    }) {
        id
    }
}
</code></pre>
<p>The mutations above will either all succeed or all fail.</p>
<h2 id="multi-canister-mutations"><a class="header" href="#multi-canister-mutations">Multi-canister mutations</a></h2>
<p>Even if you batch many mutations into one update call, if any of your mutations are custom and call into other canisters, the atomic guarantees are gone. Providing atomic operations in these situations will be more difficult for Sudograph to implement because the Internet Computer does not provide atomicity when doing multi-canister updates.</p>
<p>If you need transactions across multiple canisters, you will need to write custom code that can undo state changes across all canisters in a chain of mutations.</p>
<h1 id="multi-canister-scaling"><a class="header" href="#multi-canister-scaling">Multi-canister scaling</a></h1>
<p>Sudograph will not scale a single schema across multiple canisters automatically. The goal is to eventually provide this functionality, but the timeline and feasibility of this goal are unknown.</p>
<p>You can deploy as many Sudograph canisters with a single schema as you'd like, but the generated queries and mutations will only be able to operate on data that has been created within the same canister (unless you write your own glue code to enable cross-canister queries and mutations).</p>
<p>Currently each schema that you deploy into a canister is limited to ~4 GB of data. This should be sufficient for prototyping and small amounts of storage and usage. There are also multiple scaling techniques that could be used to scale out, for example by storing large files (video, audio, images, documents) in a separate set of canisters that has automatic scaling built-in, and storing references to that data in your Sudograph canister.</p>
<p>One of the main problems Sudograph will have scaling across multiple canisters is ensuring efficient and flexible querying. Complex indexing and searching will need to work on relational data across multiple canisters.</p>
<p>Sudograph is focused first on providing an amazing single canister development experience. This should be sufficient for many new developers and young projects. There are multiple promising technologies or solutions that could lift the ~4 GB limit, including <a href="https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md">memory64</a>, <a href="https://github.com/WebAssembly/multi-memory/blob/master/proposals/multi-memory/Overview.md">multiple memories</a>, and possibly <a href="https://forum.dfinity.org/t/abstract-away-the-4gb-canister-memory-limit/2084/19">infinite/unbounded virtual memory</a> in canisters.</p>
<p>I am hopeful that individual canisters will be able to scale into the 10s or 100s or perhaps 1000s of GBs in the near future.</p>
<h1 id="custom-database-operations"><a class="header" href="#custom-database-operations">Custom database operations</a></h1>
<p>Sudograph is designed to generate much of the CRUD functionality you might need, but it can't handle every situation. You might find the need to have access to the underlying data structures.</p>
<h2 id="sudodb"><a class="header" href="#sudodb">Sudodb</a></h2>
<p>One layer below Sudograph is Sudodb. Sudodb is a very simple relational database that uses the Internet Computer's orthogonal persistence directly. It exposes a few basic functions like <code>create</code>, <code>read</code>, <code>update</code>, and <code>delete</code>. You can use those functions directly in custom resolvers or your own functions. You can dig through the documentation and source code below:</p>
<ul>
<li><a href="https://github.com/sudograph/sudograph/tree/main/sudodb">Repository</a></li>
<li><a href="https://crates.io/crates/sudodb">Crates.io</a></li>
<li><a href="https://docs.rs/sudodb/0.2.2/sudodb/">Docs.rs</a></li>
</ul>
<p>Here's an example of how you would use Sudodb directly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::query]
async fn read_all_users() -&gt; Vec&lt;User&gt; {
    let object_type_store = sudograph::ic_cdk::storage::get::&lt;ObjectTypeStore&gt;();

    let mut selection_set_map = HashMap::new();

    selection_set_map.insert(
        String::from(&quot;id&quot;),
        sudograph::sudodb::SelectionSetInfo {
            selection_set: sudograph::sudodb::SelectionSet(None),
            search_inputs: vec![],
            limit_option: None,
            offset_option: None,
            order_inputs: vec![]
        }
    );
    
    let selection_set = sudograph::sudodb::SelectionSet(Some(selection_set_map));

    let read_result = sudograph::sudodb::read(
        object_type_store,
        &quot;User&quot;,
        &amp;vec![],
        None,
        None,
        &amp;vec![],
        &amp;selection_set
    );

    match read_result {
        Ok(strings) =&gt; {
            let deserialized_strings: Vec&lt;User&gt; = strings.iter().map(|string| {
                return sudograph::serde_json::from_str(string).unwrap();
            }).collect();

            return deserialized_strings;
        },
        Err(_) =&gt; {
            return vec![];
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="objecttypestore"><a class="header" href="#objecttypestore">ObjectTypeStore</a></h2>
<p>One layer below Sudodb is the <code>ObjectTypeStore</code>. The <code>ObjectTypeStore</code> is the main data structure that makes up the GraphQL database. You can directly read from or update the <code>ObjectTypeStore</code> in custom resolvers or your own functions. You can dig into its structure in the documentation and source code below:</p>
<ul>
<li><a href="https://github.com/sudograph/sudograph/blob/main/sudodb/src/lib.rs">Repository</a></li>
<li><a href="https://docs.rs/sudodb/0.2.2/sudodb/type.ObjectTypeStore.html">Docs.rs</a></li>
</ul>
<p>Here's an example of how you would use the <code>ObjectTypeStore</code> directly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[sudograph::ic_cdk_macros::query]
async fn read_all_users() -&gt; Vec&lt;User&gt; {
    let object_type_store = sudograph::ic_cdk::storage::get::&lt;ObjectTypeStore&gt;();

    let object_type = object_type_store.get(&quot;User&quot;).expect(&quot;should exist&quot;);

    let users = object_type.field_values_store.iter().map(|(_, field_value_store)| {
        let id = match field_value_store.get(&quot;id&quot;).expect(&quot;should exist&quot;) {
            FieldValue::Scalar(field_value_scalar_option) =&gt; match field_value_scalar_option.as_ref().expect(&quot;should exist&quot;) {
                FieldValueScalar::String(id) =&gt; ID(id.to_string()),
                _ =&gt; panic!(&quot;should not happen&quot;)
            },
            _ =&gt; panic!(&quot;should not happen&quot;)
        };

        let username = match field_value_store.get(&quot;username&quot;).expect(&quot;should exist&quot;) {
            FieldValue::Scalar(field_value_scalar_option) =&gt; match field_value_scalar_option.as_ref().expect(&quot;should exist&quot;) {
                FieldValueScalar::String(username) =&gt; username.to_string(),
                _ =&gt; panic!(&quot;should not happen&quot;)
            },
            _ =&gt; panic!(&quot;should not happen&quot;)
        };

        // This example does not show you how to resolve relations
        // You would need to go and get the blog posts by using information in the blogPosts FieldValue
        // and retrieving the records from the BlogPost object type
        let blog_posts = vec![];

        return User {
            id,
            username,
            blogPosts: blog_posts
        };
    }).collect();

    return users;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="custom-async_graphql-integration"><a class="header" href="#custom-async_graphql-integration">Custom async_graphql integration</a></h1>
<p>Sudograph is built on the bedrock of <a href="https://github.com/async-graphql/async-graphql">async_graphql</a>. <code>async_graphql</code> is the library providing most of the fundamental GraphQL functionality, includes resolving queries and mutations. Sudograph is mostly tasked with transforming your provided schema into the Rust data structures that <code>async_graphql</code> expects. Though Sudograph is designed to provide a lot of functionality for you automatically, you may find the need to dig deeper and integrate with <code>async_graphql</code> more directly.</p>
<p>The automatically generated <code>graphql_query</code> and <code>graphql_mutation</code> functions create an <code>async_graphql</code> schema data structure. These functions also accept queries and mutations and execute them against that schema. You can always generate your own functions (see <a href="./schema-sudograph-settings.html">Sudograph Settings</a>) and use <code>async_graphql</code> directly if you wish. You can see how Sudograph creates an <code>async_graphql</code> schema <a href="https://github.com/sudograph/sudograph/blob/main/sudograph-generate/src/lib.rs">here</a> (look for the <code>graphql_query</code> and <code>graphql_mutation</code> functions).</p>
<p>You can write your own <code>async_graphql</code> types as well. Basically, if you understand how Sudograph is simply generating <code>async_graphql</code> Rust data structures, including queries and mutations, you will be able to figure out how to augment the schema yourself. This could be very useful if you are waiting on Sudograph to implement a feature for you, as you might be able to implement it yourself right away with minimal effort.</p>
<h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
No custom scalars, only Blob, Boolean, Date, Float, ID, Int, JSON, and String are available</li>
<li><input disabled="" type="checkbox"/>
No custom input objects, only custom input scalars allowed in custom resolvers</li>
<li><input disabled="" type="checkbox"/>
Each schema is limited to a single canister with ~4 GB of storage</li>
<li><input disabled="" type="checkbox"/>
Very inneficient querying</li>
<li><input disabled="" type="checkbox"/>
No automatic migrations, once you deploy the schema is final unless you implement your own migrations</li>
<li><input disabled="" type="checkbox"/>
No authorization at the schema level, deal with it through your own custom authorization at the canister function level</li>
<li><input disabled="" type="checkbox"/>
No automated tests</li>
<li><input disabled="" type="checkbox"/>
No subscriptions</li>
<li><input disabled="" type="checkbox"/>
No transactions</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="src/graphql-theme.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
