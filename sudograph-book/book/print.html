<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sudograph</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="sudograph.html"><strong aria-hidden="true">1.</strong> Sudograph</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">2.</strong> Examples</a></li><li class="chapter-item expanded "><a href="quickest-of-quick-starts.html"><strong aria-hidden="true">3.</strong> Quickest of quick starts</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">4.</strong> Quick start</a></li><li class="chapter-item expanded "><a href="existing-project.html"><strong aria-hidden="true">5.</strong> Existing project</a></li><li class="chapter-item expanded "><a href="local-deployment.html"><strong aria-hidden="true">6.</strong> Local deployment</a></li><li class="chapter-item expanded "><a href="ic-deployment.html"><strong aria-hidden="true">7.</strong> IC deployment</a></li><li class="chapter-item expanded "><a href="wasm-binary-optimization.html"><strong aria-hidden="true">8.</strong> Wasm binary optimization</a></li><li class="chapter-item expanded "><a href="sudograph-client.html"><strong aria-hidden="true">9.</strong> Sudograph Client</a></li><li class="chapter-item expanded "><a href="agent-js.html"><strong aria-hidden="true">10.</strong> agent-js</a></li><li class="chapter-item expanded "><a href="schema.html"><strong aria-hidden="true">11.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema-scalars.html"><strong aria-hidden="true">11.1.</strong> Scalars</a></li><li class="chapter-item expanded "><a href="schema-objects.html"><strong aria-hidden="true">11.2.</strong> Objects</a></li><li class="chapter-item expanded "><a href="schema-relations.html"><strong aria-hidden="true">11.3.</strong> Relations</a></li><li class="chapter-item expanded "><a href="schema-custom-scalars.html"><strong aria-hidden="true">11.4.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="schema-custom-resolvers.html"><strong aria-hidden="true">11.5.</strong> Custom resolvers</a></li><li class="chapter-item expanded "><a href="schema-custom-directives.html"><strong aria-hidden="true">11.6.</strong> Custom directives</a></li><li class="chapter-item expanded "><a href="schema-sudograph-settings.html"><strong aria-hidden="true">11.7.</strong> Sudograph settings</a></li></ol></li><li class="chapter-item expanded "><a href="generated-schema.html"><strong aria-hidden="true">12.</strong> Generated schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query.html"><strong aria-hidden="true">12.1.</strong> Query</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="read.html"><strong aria-hidden="true">12.1.1.</strong> read</a></li></ol></li><li class="chapter-item expanded "><a href="mutation.html"><strong aria-hidden="true">12.2.</strong> Mutation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="create.html"><strong aria-hidden="true">12.2.1.</strong> create</a></li><li class="chapter-item expanded "><a href="update.html"><strong aria-hidden="true">12.2.2.</strong> update</a></li><li class="chapter-item expanded "><a href="delete.html"><strong aria-hidden="true">12.2.3.</strong> delete</a></li></ol></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">12.3.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="filtering.html"><strong aria-hidden="true">12.4.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="paging.html"><strong aria-hidden="true">12.5.</strong> Paging</a></li><li class="chapter-item expanded "><a href="ordering.html"><strong aria-hidden="true">12.6.</strong> Ordering</a></li></ol></li><li class="chapter-item expanded "><a href="migrations.html"><strong aria-hidden="true">13.</strong> Migrations</a></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">14.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="authorization.html"><strong aria-hidden="true">15.</strong> Authorization</a></li><li class="chapter-item expanded "><a href="vision.html"><strong aria-hidden="true">16.</strong> Vision</a></li><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">17.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">18.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="multi-canister-scaling.html"><strong aria-hidden="true">19.</strong> Multi-canister scaling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Sudograph</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sudograph"><a class="header" href="#sudograph">Sudograph</a></h1>
<p>Sudograph is a <a href="https://graphql.org/">GraphQL</a> database for the <a href="https://dfinity.org/">Internet Computer</a> (IC).</p>
<p>Its goal is to become the simplest way to develop applications for the IC. Developers start by defining a <a href="https://graphql.org/learn/schema/">GraphQL schema</a> using the <a href="https://www.digitalocean.com/community/tutorials/graphql-graphql-sdl">GraphQL SDL</a>. Once the schema is defined, it can be included within a canister and deployed to the IC. An entire relational database is generated from the schema, with GraphQL queries and mutations enabling a variety of <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations, including advanced querying over relational data.</p>
<p>Sudograph should be considered somewhere between alpha and beta software.</p>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Multiple examples are located in the <a href="https://github.com/sudograph/sudograph/tree/main/examples">examples directory</a> in the <a href="https://github.com/sudograph/sudograph">Sudograph repository</a>.</p>
<p>Here's a list of possibly useful examples:</p>
<ul>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/basic">basic</a></li>
<li><a href="https://github.com/lastmjs/ethereum-archival-canister">Ethereum Archival Canister</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/files">files 1</a></li>
<li><a href="https://github.com/dansteren/files">files 2</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/intermediate">intermediate</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/miscellaneous">miscellaneous</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/motoko-custom-resolvers">motoko-custom-resolvers</a></li>
<li><a href="https://github.com/sudograph/sudograph/tree/main/examples/rust-custom-resolvers">rust-custom-resolvers</a></li>
<li><a href="https://github.com/Ancez/sudograph-vue">sudograph-vue</a></li>
<li><a href="https://github.com/webi-ai/webi_api">webi_api</a></li>
</ul>
<h2 id="quickest-of-quick-starts-new-project"><a class="header" href="#quickest-of-quick-starts-new-project">Quickest of quick starts (new project)</a></h2>
<p>This section is designed to get you going completely from scratch. It assumes you want to have a frontend, a GraphQL playground, and the <code>graphql canister</code>. If you instead wish to integrate Sudograph into an existing project, see the <a href="./existing-project.html">Existing project section</a>.</p>
<p>If you've already got Node.js, npm, Rust, the wasm32-unknown-unknown Rust compilation target, and dfx 0.7.2 installed then just run the following commands:</p>
<pre><code class="language-bash">mkdir my-new-project
cd my-new-project
npx sudograph
dfx start --background
dfx deploy
</code></pre>
<p>Once deployed, you can visit the following canisters from a Chromium browser:</p>
<ul>
<li>playground: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a></li>
<li>frontend: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a></li>
</ul>
<p>If the above did not work, try the full installation steps in the actual <a href="./quick-start.html">quick start</a>.</p>
<p>More information is available for <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h2 id="quick-start-new-project"><a class="header" href="#quick-start-new-project">Quick start (new project)</a></h2>
<p>This section is designed to get you going completely from scratch. It assumes you want to have a frontend, a GraphQL playground, and the <code>graphql canister</code>. If you instead wish to integrate Sudograph into an existing project, see the <a href="./existing-project.html">Existing project section</a>.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You should have the following installed on your system:</p>
<ul>
<li>Node.js</li>
<li>npm</li>
<li>Rust</li>
<li>wasm32-unknown-unknown Rust compilation target</li>
<li>dfx 0.7.2</li>
</ul>
<p>If you already have the above installed, you can skip to <a href="quick-start.html#sudograph-generate">Sudograph generate</a>.</p>
<p>Run the following commands to install Node.js and npm. <a href="https://github.com/nvm-sh/nvm">nvm</a> is highly recommended and its use is shown below:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash

# restart your terminal

nvm install 14
</code></pre>
<p>Run the following command to install Rust and the wasm32-unknown-unknown target:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

rustup target add wasm32-unknown-unknown
</code></pre>
<p>Run the following command to install dfx 0.7.2:</p>
<pre><code class="language-bash"># Sudograph has been tested against version 0.7.2, so it is safest to install that specific version for now
DFX_VERSION=0.7.2 sh -ci &quot;$(curl -fsSL https://sdk.dfinity.org/install.sh)&quot;
</code></pre>
<h3 id="sudograph-generate"><a class="header" href="#sudograph-generate">Sudograph generate</a></h3>
<p>Start by making a new directory for your project. You then simply run the sudograph generate command:</p>
<pre><code class="language-bash">mkdir my-new-project

cd my-new-project

npx sudograph
</code></pre>
<h3 id="deployment"><a class="header" href="#deployment">Deployment</a></h3>
<p>Use the following links for more information about <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h1 id="existing-project"><a class="header" href="#existing-project">Existing project</a></h1>
<p>The <a href="./quickest-of-quick-starts.html">quickest of quick starts</a> and <a href="./quick-start.html">quick start</a> are both designed to get you started with an entire example project from scratch. If instead you wish to integrate Sudograph into an existing project, this section will help you to achieve that.</p>
<p>Basically you need to add a new Rust canister to your project and import and call the <code>graphql_database</code> procedural macro. If you're new to developing for the Internet Computer, you might want to check the <a href="https://sdk.dfinity.org/docs/quickstart/quickstart-intro.html">documentation</a> to get familiar with canister development. The detailed steps are listed out below, but looking at <a href="./examples.html">examples</a> might also help a lot.</p>
<p>Make sure you at least have Rust, the wasm32-unknown-unknown Rust compilation target, and dfx 0.7.2 installed on your system. If you need help setting all of that up, look at the <a href="http://localhost:3000/quick-start.html#prerequisites">prerequisites section of the quick start</a>.</p>
<p>There are a few basic steps to integrate Sudograph into an existing project:</p>
<ul>
<li>Edit <code>dfx.json</code> in root directory</li>
<li>Add <code>Cargo.toml</code> to root directory</li>
<li>Create <code>graphql canister</code> crate</li>
<li>Create GraphQL schema</li>
<li>Import and call the <code>graphql_database</code> procedural macro</li>
<li>Create candid file</li>
<li>Deploy</li>
</ul>
<h2 id="edit-dfxjson-in-root-directory"><a class="header" href="#edit-dfxjson-in-root-directory">Edit dfx.json in root directory</a></h2>
<p>Add a new canister to your <code>dfx.json</code> in the root directory of your project. You can name the canister whatever you'd like, but to keep things simple we'll call the canister <code>graphql</code>. If you have other canisters already defined, just add the <code>graphql</code> canister. The canister defined below assumes a directory structure where there is a directory called <code>canisters</code> to contain each canister. You can change up the directory structure if you'd like, just change all of the paths appropriately.:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<h2 id="add-cargotoml-to-root-directory"><a class="header" href="#add-cargotoml-to-root-directory">Add Cargo.toml to root directory</a></h2>
<p>In the root directory of your project create a <code>Cargo.toml</code> file with the following contents:</p>
<pre><code class="language-toml">[workspace]
members = [
    &quot;canisters/graphql&quot;,
]

[profile.release]
lto = true
opt-level = 'z'
</code></pre>
<p>Again this assumes your project has a <code>canisters</code> directory where the <code>graphql canister</code> will be defined. You can change the directory structure if you wish, just make sure to update this <code>Cargo.toml</code> file.</p>
<h2 id="create-graphql-canister-crate"><a class="header" href="#create-graphql-canister-crate">Create graphql canister crate</a></h2>
<p>Create a new directory within <code>canisters</code> called <code>graphql</code>, and add a <code>Cargo.toml</code> file. It should look like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;graphql&quot;
version = &quot;0.0.0&quot;
edition = &quot;2018&quot;

[lib]
path = &quot;src/graphql.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
sudograph = &quot;0.3.0&quot;
ic-cdk = &quot;0.3.0&quot; # TODO this will go away once https://github.com/dfinity/candid/pull/249 is released
</code></pre>
<p>Within the <code>canisters/graphql</code> directory, now create a <code>src</code> directory. The <code>canisters/graphql/src</code> directory will contain your GraphQL schema, the Rust entrypoint to your <code>graphql canister</code>, and your candid file.</p>
<h2 id="create-graphql-schema"><a class="header" href="#create-graphql-schema">Create GraphQL schema</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>schema.graphql</code> file. The following is just an example:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<h2 id="import-and-call-the-graphql_database-procedural-macro"><a class="header" href="#import-and-call-the-graphql_database-procedural-macro">Import and call the <code>graphql_database</code> procedural macro</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>graphql.rs</code> file. The file should look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This simply imports the <code>graphql_database</code> procedural macro from <code>sudograph</code> and then invokes it with the path to your <code>schema.graphql</code> file. This is where the magic happens and the database with CRUD queries and mutations are all generated.</p>
<h2 id="create-candid-file"><a class="header" href="#create-candid-file">Create candid file</a></h2>
<p>Within the <code>canisters/graphql/src</code> directory, create your <code>graphql.did</code> file. The file should look like this:</p>
<pre><code>service : {
    &quot;graphql_query&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation&quot;: (text, text) -&gt; (text);
}
</code></pre>
<p>The generated canister code will have created the two functions defined in <code>graphql.did</code>, but for now you'll need to create the candid file manually. Hopefully in the future it can be generated for you or abstracted away somehow.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both take two parameters. The first parameter is the query or mutation string. The second parameter is a JSON string containing any variables for the query or mutation. Currently the second parameter is required, so just send an empty JSON object string <code>&quot;{}&quot;</code> if no variables are required for the query or mutation.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both return the result of the query or mutation as a JSON string. Whatever client is consuming the query or mutation will then need to parse the JSON string to turn it into a language-level object. The <a href="./sudograph-client.html">Sudograph Client</a> will do this for you in a JavaScript frontend.</p>
<h2 id="deploy"><a class="header" href="#deploy">Deploy</a></h2>
<p>Use the following links for more information about <a href="./local-deployment.html">local deployment</a> and <a href="./ic-deployment.html">IC deployment</a>.</p>
<h1 id="local-deployment"><a class="header" href="#local-deployment">Local deployment</a></h1>
<p>Start up an IC replica and deploy:</p>
<pre><code class="language-bash"># Open a terminal and run the following command to start a local IC replica
dfx start

# Alternatively to the above command, you can run the replica in the background
dfx start --background

# If you are running the replica in the background, you can run this command within the same terminal as the dfx start --background command
# If you are not running the replica in the background, then open another terminal and run this command from the root directory of your project
dfx deploy
</code></pre>
<p>Make sure to run <code>dfx deploy</code> for your first deploy. For quicker deployments after the first, you can run <code>dfx deploy graphql</code> if you've only changed your schema or the Rust code within the <code>graphql canister</code>. <code>dfx deploy graphql</code> will only deploy the <code>graphql canister</code>, which contains the generated database.</p>
<h2 id="playground-canister"><a class="header" href="#playground-canister">playground canister</a></h2>
<p>Start executing GraphQL queries and mutations against your database by going to the following URL in a Chromium browser: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a>.</p>
<h2 id="frontend-canister"><a class="header" href="#frontend-canister">frontend canister</a></h2>
<p>View a simple frontend application that communicates with the <code>graphql canister</code> by going to the following URL in a Chromium browser: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a>.</p>
<h2 id="command-line"><a class="header" href="#command-line">command line</a></h2>
<p>You can execute queries against the <code>graphql canister</code> from the command line if you wish:</p>
<pre><code class="language-bash"># send a query to the graphql canister
dfx canister call graphql graphql_query '(&quot;query { readUser { id } }&quot;, &quot;{}&quot;)'

# send a mutation to the graphql canister
dfx canister call graphql graphql_mutation '(&quot;mutation { createUser(input: { username: \&quot;lastmjs\&quot; }) { id } }&quot;, &quot;{}&quot;)'
</code></pre>
<h2 id="sudograph-client"><a class="header" href="#sudograph-client">Sudograph Client</a></h2>
<p>Still needs to be documented.</p>
<h2 id="rust-canister"><a class="header" href="#rust-canister">Rust canister</a></h2>
<p>If you want to call into the <code>graphql canister</code> from another Rust canister:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO fill out this example, show queries and mutations
<span class="boring">}
</span></code></pre></pre>
<h2 id="motoko-canister"><a class="header" href="#motoko-canister">Motoko canister</a></h2>
<p>If you want to call into the <code>graphql canister</code> from a Motoko canister:</p>
<pre><code class="language-motoko">// TODO fill out this example, show queries and mutations
</code></pre>
<h2 id="wasm-binary-optimization"><a class="header" href="#wasm-binary-optimization">Wasm binary optimization</a></h2>
<p>If the replica rejects deployment of your canister because the payload is too large, you may need to <a href="./wasm-binary-optimization.html">optimize your Wasm binary</a>.</p>
<h1 id="ic-deployment"><a class="header" href="#ic-deployment">IC deployment</a></h1>
<p>Before deploying to the Internet Computer you should understand that Sudograph is alpha/beta software. There are missing features and potential bugs. There is also no way to easily migrate data (if you change your schema, you'll need to either delete your state and start over or manually make changes to the Sudograph data structures). But if you must deploy to the IC, here is the command:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<h2 id="wasm-binary-optimization-1"><a class="header" href="#wasm-binary-optimization-1">Wasm binary optimization</a></h2>
<p>If the replica rejects deployment of your canister because the payload is too large, you may need to <a href="./wasm-binary-optimization.html">optimize your Wasm binary</a>.</p>
<h1 id="wasm-binary-optimization-2"><a class="header" href="#wasm-binary-optimization-2">Wasm binary optimization</a></h1>
<p>At some point your compiled Rust Wasm binary will grow too large and will be rejected by the canister on deploy. This could happen because the Rust source code that you've written has grown too large, or because your schema has grown too large. A large schema will lead to a large amount of generated Rust code.</p>
<p>To temporarily overcome this issue (only so much can be done during optimization, eventually the binary will be too big and the Internet Computer will need to address that), you can optimize your Rust Wasm binary.</p>
<h3 id="manual-optimization"><a class="header" href="#manual-optimization">Manual optimization</a></h3>
<p>To do this manually, in the root of your directory run the following command once to install the optimizer:</p>
<pre><code class="language-bash">cargo install ic-cdk-optimizer --root target
</code></pre>
<p>You should also change your <code>dfx.json</code> file from:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<p>to:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;
        }
    }
}
</code></pre>
<p>The only thing that changed was the <code>wasm</code> property of the <code>graphql</code> canister object, and it changed from <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;</code> to <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;</code>.</p>
<p>Each time you run <code>dfx deploy</code> or <code>dfx deploy graphql</code>, you will need to run the following command after:</p>
<pre><code class="language-bash">./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimized.wasm
</code></pre>
<h3 id="automatic-optimization"><a class="header" href="#automatic-optimization">Automatic optimization</a></h3>
<p>It can be tedious to have to run the above command manually after each <code>dfx deploy</code>. If you wish to figure out how to use <code>cargo</code> scripts of some kind you can do that. You could also use <code>make</code> or <code>bash</code> or some other build process or scripting system.</p>
<p>Another way is to adopt npm scripts. Your <code>package.json</code> could look something like this:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;cd canisters/playground &amp;&amp; npm install &amp;&amp; npm run build &amp;&amp; cd ../frontend &amp;&amp; npm install &amp;&amp; npm run build&quot;,
        &quot;dfx-deploy&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy&quot;,
        &quot;dfx-deploy-graphql&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy graphql&quot;,
        &quot;dfx-build-graphql&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
        &quot;dfx-optimize-graphql&quot;: &quot;./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;
    }
}
</code></pre>
<p>Then instead of running <code>dfx deploy</code> or <code>dfx deploy graphql</code> you would run <code>npm run dfx-deploy</code> or <code>npm run dfx-deploy-graphql</code>.</p>
<p>In the future it would be nice for the <code>dfx.json</code> to allow for some sort of build scripts, which would make this process less messy. There is an open forum post about this <a href="https://forum.dfinity.org/t/dfx-json-build-scripts/4922">here</a></p>
<h1 id="sudograph-client-1"><a class="header" href="#sudograph-client-1">Sudograph Client</a></h1>
<p>The Sudograph Client is a frontend JavaScript/TypeScript library that provides a convenient API for interacting with your deployed <code>graphql canister</code>. It is an alternative to using <a href="./agent-js.html">agent-js</a> directly, and currently works only for the frontend (Node.js support will come later).</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Install Sudograph Client into your frontend project with <code>npm install sudograph</code>.</p>
<h2 id="use"><a class="header" href="#use">Use</a></h2>
<p>In addition to the code on this page, many of the <a href="./examples.html">examples</a> have frontend projects that show Sudograph Client in use.</p>
<p>For our example, let's imagine we have some sort of frontend UI component defined in a JavaScript file called <code>component.js</code>. You could import and prepare Sudograph Client for use as follows:</p>
<pre><code class="language-javascript">// component.js

import {
    gql,
    sudograph
} from 'sudograph';

const {
    query,
    mutation
} = sudograph({
    canisterId: 'ryjl3-tyaaa-aaaaa-aaaba-cai'
});
</code></pre>
<p>Above we import the <code>gql</code> tag and the <code>sudograph</code> function. The <code>gql</code> tag will be used for queries later on. To prepare for <code>query</code> or <code>mutation</code> execution, we call the <code>sudograph</code> function and pass in an options object. In this case, we simply put in the canister id of our <code>graphql canister</code>. The options object looks like this in TypeScript:</p>
<pre><code class="language-typescript">import { Identity } from '@dfinity/agent';

export type Options = Readonly&lt;{
    canisterId: string;
    identity?: Identity;
    queryFunctionName?: string;
    mutationFunctionName?: string;
}&gt;;
</code></pre>
<h2 id="query"><a class="header" href="#query">query</a></h2>
<p>If we want to execute a query, we would do so as follows. Imagine defining a function to return all user ids:</p>
<pre><code class="language-javascript">// component.js

async function getUserIds() {
    const result = await query(gql`
        query {
            readUser {
                id
            }
        }
    `);

    const users = result.data.readUser;

    return users;
}
</code></pre>
<p>By the way, the <code>gql</code> tag is just a nice way to integrate with existing editor tools, such as syntax highlighting and type checking. You can remove it if you'd like.</p>
<h2 id="mutation"><a class="header" href="#mutation">mutation</a></h2>
<p>If we want to execute a mutation, we would do so as follows. Imagine defining a function to create a user:</p>
<pre><code class="language-javascript">// component.js

async function createUser(username) {
    const result = await mutation(gql`
        mutation ($username: String!) {
            createUser(input: {
                username: $username
            }) {
                id
            }
        }
    `, {
        username
    });

    const user = result.data.createUser;

    return user;
}
</code></pre>
<h2 id="changing-query-and-mutation-canister-function-names"><a class="header" href="#changing-query-and-mutation-canister-function-names">Changing query and mutation canister function names</a></h2>
<p>The <code>queryFunctionName</code> and <code>mutationFunctionName</code> properties of the options object that we pass into the <code>sudograph</code> function allow us to specify the names of the canister functions that are exposed by our <code>graphql canister</code>. By default the generated query and mutation function names are <code>graphql_query</code> and <code>graphql_mutation</code>. Sudograph Client will assume those names should be used unless <code>queryFunctionName</code> and <code>mutationFunctionName</code> are supplied by the developer.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The <code>identity</code> property of the options object that we pass into the <code>sudograph</code> function helps us out with authentication, and its type is defined by <a href="https://github.com/dfinity/agent-js">@dfinity/agent</a>. If we pass in an <code>identity</code> object, it will be passed into the constructor of the <code>@dfinity/agent</code> <code>HttpAgent</code> that Sudograph Client is creating for you under the hood. This identity will be used to sign query and mutation requests, allowing you to implement authorization inside of your <code>graphql canister</code>.</p>
<p>The <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">files example</a> shows how to use Internet Identity with a <code>graphql canister</code>.</p>
<h1 id="agent-js"><a class="header" href="#agent-js">agent-js</a></h1>
<p>If you don't wish to use <a href="./sudograph-client.html">Sudograph Client</a>, you can reach for the lower-level <a href="https://github.com/dfinity/agent-js">agent-js</a> library.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Install <code>agent-js</code> into your frontend project with <code>npm install @dfinity/agent</code>.</p>
<h2 id="use-1"><a class="header" href="#use-1">Use</a></h2>
<p>In addition to the code on this page, <a href="https://github.com/sudograph/sudograph/blob/main/client/sudograph.ts">the Sudograph Client implementation</a> is a very good example of how to use <code>agent-js</code> directly to interact with a <code>graphql canister</code>.</p>
<p>For our example, let's imagine we have some sort of frontend UI component defined in a JavaScript file called <code>component.js</code>. You could import and prepare <code>agent-js</code> for use as follows:</p>
<pre><code class="language-javascript">// component.js

import {
    Actor,
    HttpAgent
} from '@dfinity/agent';

const idlFactory = ({ IDL }) =&gt; {
    return IDL.Service({
        graphql_query: IDL.Func([IDL.Text, IDL.Text], [IDL.Text], ['query']),
        graphql_mutation: IDL.Func([IDL.Text, IDL.Text], [IDL.Text], [])
    });
};

const agent = new HttpAgent();

const actor = Actor.createActor(idlFactory, {
    agent,
    canisterId: 'ryjl3-tyaaa-aaaaa-aaaba-cai'
});
</code></pre>
<p>Above we manually construct an <code>IDL Factory</code> describing the <code>graphql_query</code> and <code>graphql_mutation</code> functions exported from our canister. We then create an <code>agent</code> and use that agent with the canister id of our <code>graphql canister</code> to create an actor.</p>
<h2 id="query-1"><a class="header" href="#query-1">query</a></h2>
<p>If we want to execute a query, we would do so as follows. Imagine defining a function to return all user ids:</p>
<pre><code class="language-javascript">// component.js

async function getUserIds() {
    const result = await actor.graphql_query(`
        query {
            readUser {
                id
            }
        }
    `, JSON.stringify({}));

    const resultJSON = JSON.parse(result);

    const users = resultJSON.data.readUser;

    return users;
}
</code></pre>
<h2 id="mutation-1"><a class="header" href="#mutation-1">mutation</a></h2>
<p>If we want to execute a mutation, we would do so as follows. Imagine defining a function to create a user:</p>
<pre><code class="language-javascript">// component.js

async function createUser(username) {
    const result = await actor.graphql_mutation(`
        mutation ($username: String!) {
            createUser(input: {
                username: $username
            }) {
                id
            }
        }
    `, JSON.stringify({
        username
    }));

    const resultJSON = JSON.parse(result);

    const user = resultJSON.data.createUser;

    return user;
}
</code></pre>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<p>The <code>HttpAgent</code> from <code>@dfinity/agent</code> takes an object as a parameter to its contructor. That object has a property called <code>identity</code> of type <code>Identity</code> which can be found in <code>@dfinity/agent</code>. This identity will be used to sign requests made by the actor object that we create, allowing you to implement authorization inside of your <code>graphql canister</code>.</p>
<p>The <a href="https://github.com/sudograph/sudograph/blob/main/examples/files/canisters/files/elements/files-app.ts">files example</a> shows how to use Internet Identity with a <code>graphql canister</code>.</p>
<h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>The schema is where you define all of the data types of your application, including relations between types. It is also where you will eventually define many other settings, possibly including authentication, authorization, subnet, and Sudograph-specific settings.</p>
<p>An example schema might look like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<p>We have told Sudograph that we have two object types, <code>User</code> and <code>BlogPost</code>. We've described the fields of each type, using some included scalar types such as <code>ID</code>, <code>Date</code>, and <code>String</code>. We have also described one relation between our two types, a one-to-many relationship from <code>User</code> to <code>BlogPost</code> on the fields <code>User:blogPosts</code> and <code>BlogPost:author</code>.</p>
<p>The schema is an incredibly powerful yet simple tool for defining the complex data types of your application. Get to know the possibilities of your schema:</p>
<ul>
<li><a href="./schema-scalars.html">Scalars</a></li>
<li><a href="./schema-objects.html">Objects</a></li>
<li><a href="./schema-relations.html">Relations</a></li>
<li><a href="./schema-custom-scalars.html">Custom scalars</a></li>
<li><a href="./schema-custom-resolvers.html">Custom resolvers</a></li>
<li><a href="./schema-custom-directives.html">Custom directives</a></li>
<li><a href="./schema-sudograph-settings.html">Sudograph settings</a></li>
</ul>
<h1 id="scalars"><a class="header" href="#scalars">Scalars</a></h1>
<p>Scalar types are not divisible, they have no fields of their own. The scalar types automatically available to you in a Sudograph schema are:</p>
<ul>
<li><a href="schema-scalars.html#blob">Blob</a></li>
<li><a href="schema-scalars.html#boolean">Boolean</a></li>
<li><a href="schema-scalars.html#date">Date</a></li>
<li><a href="schema-scalars.html#float">Float</a></li>
<li><a href="schema-scalars.html#id">ID</a></li>
<li><a href="schema-scalars.html#int">Int</a></li>
<li><a href="schema-scalars.html#json">JSON</a></li>
<li><a href="schema-scalars.html#string">String</a></li>
</ul>
<h2 id="blob"><a class="header" href="#blob">Blob</a></h2>
<p>A <code>Blob</code> value maps to a Rust <code>Vec&lt;u8&gt;</code>.</p>
<pre><code class="language-graphql">type File {
    id: ID!
    contents: Blob!
}
</code></pre>
<p>Query or mutation inputs of type <code>Blob</code> should be strings or arrays of numbers that can be converted into Rust u8 numbers. <code>Blob</code> types in selection sets are always returned as JSON arrays of numbers.</p>
<p>An example in JavaScript of inputting a string for a <code>Blob</code>:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents
            }
        }
    `, {
        contents: 'hello'
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[104, 101, 108, 108, 111]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[104, 101, 108, 108, 111].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<p>An example in JavaScript of inputting an array of numbers for a <code>Blob</code>:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents
            }
        }
    `, {
        contents: 'hello'.split('').map(x =&gt; x.charCodeAt())
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[104, 101, 108, 108, 111]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[104, 101, 108, 108, 111].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<p><code>Blob</code> types in selection sets can use <code>offset</code> and <code>limit</code> to grab specific bytes:</p>
<pre><code class="language-javascript">async function createSmallFile() {
    const result = await mutation(gql`
        mutation ($contents: Blob!) {
            createFile(input: {
                contents: $contents
            }) {
                contents(offset: 1, limit: 3)
            }
        }
    `, {
        contents: 'hello'
    });

    const file = result.data.createFile;

    console.log(file);
}
</code></pre>
<p>The logged contents of the file would be this: <code>[101, 108, 108]</code>.</p>
<p>You can convert the array of numbers back to a string like so:</p>
<pre><code class="language-javascript">[101, 108, 108].map(x =&gt; String.fromCharCode(x)).join('')
</code></pre>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>A <code>Boolean</code> value maps to a Rust <code>bool</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    verified: Boolean!
}
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>A <code>Date</code> value maps to a Rust <code>String</code> for storage and a <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">chrono::DateTime</a> for filtering.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    dateOfBirth: Date!
}
</code></pre>
<p>Query or mutation inputs of type <code>Date</code> should be strings that can be parsed by <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">chrono::DateTime</a>. For example, in JavaScript <code>new Date().toISOString()</code> would be an acceptable format.</p>
<p>An example in JavaScript:</p>
<pre><code class="language-javascript">async function getUsersInInterval() {
    const result = await query(gql`
        query ($startDate: Date!, $endDate: Date!) {
            readUser(search: {
                dateOfBirth: {
                    gte: $startDate
                    lt: $endDate
                }
            }) {
                id
            }
        }
    `, {
        startDate: new Date('2021-07-01').toISOString(),
        endDate: new Date('2021-07-02').toISOString()
    });

    const users = result.data.readUser;

    return users;
}
</code></pre>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>A <code>Float</code> value maps to a Rust <code>f32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    height: Float!
}
</code></pre>
<h2 id="id"><a class="header" href="#id">ID</a></h2>
<p>An <code>ID</code> value maps to a Rust <code>String</code>. All Sudograph object types must have a field called <code>id</code> of type <code>ID</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>An <code>Int</code> value maps to a Rust <code>i32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    age: Int!
}
</code></pre>
<h2 id="json"><a class="header" href="#json">JSON</a></h2>
<p>A <code>JSON</code> value maps to a Rust <code>String</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    meta: JSON!
}
</code></pre>
<p>Query or mutation inputs of type <code>JSON</code> should be any valid JSON value. <code>JSON</code> types in selection sets are always returned as JSON values.</p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>A <code>String</code> value maps to a Rust <code>String</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
}
</code></pre>
<h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Object types have fields that may be other object types or scalar types. Object types allow you to define the truly custom data types and relations that make up your application.</p>
<p>You could model a user with blog posts like so:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts::BlogPost:author&quot;)
}
</code></pre>
<p>You could model a family tree like so:</p>
<pre><code class="language-graphql"># TODO this example will not work yet
# TODO the self-referencing has some issues and multiple @relation directives per field is not yet supported
type Person {
    id: ID!
    firstName: String!
    lastName: String!
    father: Person @relation(name: &quot;Person:father::Person:children&quot;)
    mother: Person @relation(name: &quot;Person:mother::Person:children&quot;)
    children: [Person!]!
        @relation(name: &quot;Person:father::Person:children&quot;)
        @relation(name: &quot;Person:mother::Person:children&quot;)
}
</code></pre>
<p>You could model Ethereum block data like so:</p>
<pre><code class="language-graphql">type Block {
    id: ID!
    number: Int!
    hash: String!
    parent: Block
    transactionsRoot: String!
    transactionCount: Int!
    stateRoot: String!
    gasLimit: String!
    gasUsed: String!
    timestamp: Date!
    transactions: [Transaction!]! @relation(name: &quot;Block:transactions::Transaction:block&quot;)
}

type Transaction {
    id: ID!
    hash: String!
    index: Int!
    from: String!
    to: String!
    value: String!
    gasPrice: String!
    gas: String!
    inputData: String!
    block: Block! @relation(name: &quot;Block:transactions::Transaction:block&quot;)
    gasUsed: String!
}
</code></pre>
<h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>Relations allow you to describe the relationships between object types and their fields. Sudograph has a variety of relation capabilities.</p>
<p>Please note that the <code>name</code> argument of the <code>@relation</code> directive is just an arbitrary string, there is no DSL required. The only requirement is that the <code>name</code> argument be the same on both sides of the relation.</p>
<p>Also note that you can only have one <code>@relation</code> directive per field for now.</p>
<h2 id="one-to-one-relations"><a class="header" href="#one-to-one-relations">One-to-one relations</a></h2>
<p>One-to-one relations allow you to connect one object with another object.</p>
<h3 id="one-sided"><a class="header" href="#one-sided">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe
}

type Shoe {
    id: ID!
}
</code></pre>
<p>In the above example, you will be able to select the shoe of a foot, like so:</p>
<pre><code class="language-graphql">query {
    readFoot(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        shoe {
            id
        }
    }
}
</code></pre>
<p>You will not be able to select the foot of a shoe.</p>
<h3 id="two-sided"><a class="header" href="#two-sided">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}

type Shoe {
    id: ID!
    foot: Foot @relation(name: &quot;Foot:shoe::Shoe:foot&quot;)
}
</code></pre>
<h2 id="one-to-many-relations"><a class="header" href="#one-to-many-relations">One-to-many relations</a></h2>
<p>One-to-many relations allow you to connect one object with multiple other objects.</p>
<h3 id="one-sided-1"><a class="header" href="#one-sided-1">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]!
}

type Banana {
    id: ID!
    color: String!
    size: Int!
}
</code></pre>
<p>In the above example, you will be able to select the bananas of a monkey, like so:</p>
<pre><code class="language-graphql">query {
    readMonkey(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        name
        bananas {
            id
            color
            size
        }
    }
}
</code></pre>
<p>You will not be able to select the monkey of a banana.</p>
<h3 id="two-sided-1"><a class="header" href="#two-sided-1">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]! @relation(name: &quot;Monkey:bananas::Banana:monkey&quot;)
}

type Banana {
    id: ID!
    color: String!
    size: Int!
    monkey: Monkey @relation(name: &quot;Monkey:bananas::Banana:monkey&quot;)
}
</code></pre>
<h2 id="many-to-many-relations"><a class="header" href="#many-to-many-relations">Many-to-many relations</a></h2>
<p>Many-to-many relations allow you to connect multiple objects with multiple other objects. Many-to-many relations must have a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Author {
    id: ID!
    documents: [Document!]! @relation(name: &quot;Author:documents::Document:authors&quot;)
}

type Document {
    id: ID!
    text: String!
    authors: [Author!]! @relation(name: &quot;Author:documents::Document:authors&quot;)
}
</code></pre>
<h1 id="custom-scalars"><a class="header" href="#custom-scalars">Custom scalars</a></h1>
<p>Custom scalars (scalars that you define) are not yet supported. You'll have to work with the included scalars:</p>
<ul>
<li><a href="./schema-scalars.html#blob">Blob</a></li>
<li><a href="./schema-scalars.html#boolean">Boolean</a></li>
<li><a href="./schema-scalars.html#date">Date</a></li>
<li><a href="./schema-scalars.html#float">Float</a></li>
<li><a href="./schema-scalars.html#id">ID</a></li>
<li><a href="./schema-scalars.html#int">Int</a></li>
<li><a href="./schema-scalars.html#json">JSON</a></li>
<li><a href="./schema-scalars.html#string">String</a></li>
</ul>
<h1 id="custom-resolvers"><a class="header" href="#custom-resolvers">Custom resolvers</a></h1>
<p>Custom resolvers where the resolver function is defined within the same Rust canister as the <code>graphql_database</code> macro are possible now, but not well-documented.  See the <a href="https://github.com/sudograph/sudograph/tree/main/examples/intermediate">intermediate example</a> for a very rough overview of how to achieve this.</p>
<p>Custom resolvers where the resolver function is defined in a separate canister (be it written in Rust, Motoko, AssemblyScript, or any other language) are also supported. For now you will need to write a custom resolver in Rust that does a cross-canister call to the resolver in the separate canister. This is not well-documented but is possible. In the future, the plan is for those types of custom resolvers to be defined only in the schema so that no Rust code is required. It will look like this:</p>
<pre><code class="language-graphql"># schema.graphql

type Query {
    myCustomQueryResolver(param1: Int!): Boolean! @canister(id: &quot;renrk-eyaaa-aaaaa-aaada-cai&quot;)
}

type Mutation {
    myCustomMutationResolver(param1: Float!): String! @canister(id: &quot;rdmx6-jaaaa-aaaaa-aaadq-cai&quot;)
}
</code></pre>
<p>Defining the above <code>Query</code> and <code>Mutation</code> object types in your schema would generate two custom resolver functions in the Rust canister where the <code>graphql_database</code> macro is used. These resolver functions would perform cross-canister calls to a canister with the id defined in the <code>@canister</code> directive. You would then need to define <code>myCustomQueryResolver</code> with the appropriate parameters and return type in the <code>renrk-eyaaa-aaaaa-aaada-cai</code> canister, and <code>myCustomMutationResolver</code> with the appropriate parameters and return type in the <code>rdmx6-jaaaa-aaaaa-aaadq-cai</code> canister.</p>
<h1 id="custom-directives"><a class="header" href="#custom-directives">Custom directives</a></h1>
<h1 id="sudograph-settings"><a class="header" href="#sudograph-settings">Sudograph settings</a></h1>
<p>There will be many settings that Sudograph will allow the developer to customize. Sudograph settings are set in your GraphQL schema using the <code>SudographSettings</code> object type. The following are supported now:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedQueryFunction: true
    exportGeneratedMutationFunction: true
    exportGeneratedInitFunction: true
    exportGeneratedPostUpgradeFunction: true
}
</code></pre>
<h1 id="exportgeneratedqueryfunction"><a class="header" href="#exportgeneratedqueryfunction">exportGeneratedQueryFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>graphql_query</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic before executing a query, for example as part of an authorization flow.</p>
<p>Here's an example of overriding the generated <code>graphql_query</code> function with some basic authorization. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedQueryFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::query]
async fn graphql_query_custom(query_string: String, variables_json_string: String) -&gt; String {
    let authorized_principal = sudograph::ic_cdk::export::Principal::from_text(&quot;y6lgw-chi3g-2ok7i-75s5h-k34kj-ybcke-oq4nb-u4i7z-vclk4-hcpxa-hqe&quot;).expect(&quot;should be able to decode&quot;);
    
    if sudograph::ic_cdk::caller() != authorized_principal {
        panic!(&quot;Not authorized&quot;);
    }

    return graphql_query(query_string, variables_json_string).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>You would update <code>canisters/graphql/src/graphql.did</code>:</p>
<pre><code>service : {
    &quot;graphql_query_custom&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation&quot;: (text, text) -&gt; (text);
}
</code></pre>
<h1 id="exportgeneratedmutationfunction"><a class="header" href="#exportgeneratedmutationfunction">exportGeneratedMutationFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>graphql_mutation</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic before executing a mutation, for example as part of an authorization flow.</p>
<p>Here's an example of overriding the generated <code>graphql_mutation</code> function with some basic authorization. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedMutationFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::update]
async fn graphql_mutation_custom(mutation_string: String, variables_json_string: String) -&gt; String {
    let authorized_principal = sudograph::ic_cdk::export::Principal::from_text(&quot;y6lgw-chi3g-2ok7i-75s5h-k34kj-ybcke-oq4nb-u4i7z-vclk4-hcpxa-hqe&quot;).expect(&quot;should be able to decode&quot;);
    
    if sudograph::ic_cdk::caller() != authorized_principal {
        panic!(&quot;Not authorized&quot;);
    }

    return graphql_mutation(mutation_string, variables_json_string).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>You would update <code>canisters/graphql/src/graphql.did</code>:</p>
<pre><code>service : {
    &quot;graphql_query&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation_custom&quot;: (text, text) -&gt; (text);
}
</code></pre>
<h1 id="exportgeneratedinitfunction"><a class="header" href="#exportgeneratedinitfunction">exportGeneratedInitFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>init</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic during canister initialization. You'll want to make sure to call the generated <code>init</code> function after your functionality is complete, as it executes all of the <code>init</code> mutations that initialize the database.</p>
<p>Here's an example of overriding the generated <code>init</code> function. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedInitFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::init]
async fn init_custom() {
    init.await;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="exportgeneratedpostupgradefunction"><a class="header" href="#exportgeneratedpostupgradefunction">exportGeneratedPostUpgradeFunction</a></h1>
<p>Defaults to <code>true</code>. If set to <code>false</code>, the <code>post_upgrade</code> function generated by Sudograph will not be exported as a publicly available canister function. This would allow you to implement your own logic during canister post upgrade. You'll want to make sure to call the generated <code>post_upgrade</code> function after your functionality is complete, as it executes all of the <code>init</code> mutations that initialize the database (unless you are keeping your state through stable memory, then you would not want to initialize the database again).</p>
<p>Here's an example of overriding the generated <code>post_upgrade</code> function. You would create the following GraphQL schema in <code>canisters/graphql/src/schema.graphql</code>:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedPostUpgradeFunction: false
}

type User {
    id: ID!
}
</code></pre>
<p>You would write the following in <code>canisters/graphql/src/graphql.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);

#[sudograph::ic_cdk_macros::post_upgrade]
async fn post_upgrade_custom() {
    post_upgrade.await;
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="generated-schema"><a class="header" href="#generated-schema">Generated Schema</a></h1>
<p>Sudograph takes your <a href="./schema.html">schema</a> and generates a much more powerful schema.</p>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="query-2"><a class="header" href="#query-2">Query</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="read"><a class="header" href="#read">read</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="mutation-2"><a class="header" href="#mutation-2">Mutation</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="create"><a class="header" href="#create">create</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="update"><a class="header" href="#update">update</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="delete"><a class="header" href="#delete">delete</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="subscription"><a class="header" href="#subscription">Subscription</a></h1>
<p>This is not yet implemented</p>
<h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="paging"><a class="header" href="#paging">Paging</a></h1>
<p>Not yet implemented</p>
<h1 id="ordering"><a class="header" href="#ordering">Ordering</a></h1>
<p>Not yet implemented</p>
<h1 id="migrations"><a class="header" href="#migrations">Migrations</a></h1>
<p>Automated migrations are not currently supported. If you wish to update a Sudograph canister that has already been deployed, you will lose all of your saved data unless you implement your own migrations.</p>
<p>You can implement your own migrations by implementing and exporting <code>pre_upgrade</code> and <code>post_upgrade</code> canister functions. You can save your state to stable memory in the <code>pre_upgrade</code> function, and restore that state in the <code>post_upgrade</code> function. See <a href="https://sdk.dfinity.org/docs/developers-guide/working-with-canisters.html">here</a> and <a href="https://github.com/dfinity/cdk-rs/blob/main/examples/asset_storage/src/asset_storage_rs/lib.rs">here</a> for more information.</p>
<p>The plan is to eventually automate migrations as much as possible. If you change your schema and wish to update it on a live canister, Sudograph will generate migrations written in Rust to accomplish the migration for you. If a migration cannot be performed automatically, Sudograph will allow you to easily define your own migration code in Rust. That's the rough plan for now.</p>
<p>But until then, you're on your own. Good luck soldier.</p>
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>Sudograph does not have a strong guarantee of atomicity (transactions) at this time. Read on for more information.</p>
<h2 id="single-canister-mutations"><a class="header" href="#single-canister-mutations">Single canister mutations</a></h2>
<p>Within a single update call, transactions are automatically handled by the Internet Computer itself! If there are any errors (technically Wasm traps) all state changes are undone and thus not persisted.</p>
<p>This is a very nice feature of single canister development. If you don't know already you need to know that the schema that Sudograph generates for you is limited to a single canister by default. If you need to scale across canisters, you will need to write custom code.</p>
<p>Unfortunately, Sudograph does not currently guarantee that all errors will lead to traps that undo all state changes. It should not be too difficult to add, but currently you do not have a guarantee that all mutations within a single update call will be executed atomically.</p>
<p>Once Sudograph ensures all errors will lead to traps, you will be able to ensure atomicity by executing many mutations within a single update call like this:</p>
<pre><code class="language-graphql">mutation {
    createUser1: createUser(input: {
        username: &quot;user1&quot;
    }) {
        id
    }

    createUser2: createUser(input: {
        username: &quot;user2&quot;
    }) {
        id
    }

    createUser3: createUser(input: {
        username: &quot;user3&quot;
    }) {
        id
    }
}
</code></pre>
<p>All of the mutations above will either all succeed or all fail.</p>
<h2 id="multi-canister-mutations"><a class="header" href="#multi-canister-mutations">Multi-canister mutations</a></h2>
<p>Even if you batch many mutations into one update call, if any of your mutations are custom and call into other canisters, the atomic guarantees are gone. This will be more difficult for Sudograph to implement because the Internet Computer does not provide atomicity when doing multi-canister updates.</p>
<p>If you need transactions across multiple canisters, you will need to write custom code that undoes state changes across all canisters in a chain of mutations.</p>
<h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<h1 id="vision"><a class="header" href="#vision">Vision</a></h1>
<p>Not yet well-documented, sheesh!</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Not yet well-documented, sheesh!</p>
<h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
No paging or ordering of records</li>
<li><input disabled="" type="checkbox"/>
No custom scalars, only Int, Float, String, ID, Boolean, and Date are available</li>
<li><input disabled="" type="checkbox"/>
Filtering is limited to the top level selection set</li>
<li><input disabled="" type="checkbox"/>
Limited to a single canister ~4GB of storage</li>
<li><input disabled="" type="checkbox"/>
Very inneficient querying, be careful once you get into the 100,000s or 1,000,000s of records</li>
<li><input disabled="" type="checkbox"/>
No automatic migrations, once you deploy the schema is final unless you implement your own migrations</li>
<li><input disabled="" type="checkbox"/>
No authorization at the schema level, deal with it through your own custom authorization at the canister function level</li>
<li><input disabled="" type="checkbox"/>
No automated tests</li>
<li><input disabled="" type="checkbox"/>
No subscriptions</li>
<li><input disabled="" type="checkbox"/>
No transactions</li>
</ul>
<h1 id="multi-canister-scaling"><a class="header" href="#multi-canister-scaling">Multi-canister scaling</a></h1>
<p>Sudograph will not scale a single schema across multiple canisters automatically. The goal is to eventually provide this functionality, but the timeline and feasibility of this goal are unknown.</p>
<p>Currently each schema that you deploy into a canister is limited to ~4GB of data. This should be sufficient for prototyping and small amounts of storage and usage. There are also multiple scaling techniques that could be used to scale out, for example by storing large files (video, audio, images, documents) in a separate set of canisters that has automatic scaling built-in, and storing references to that data in your Sudograph canister.</p>
<p>One of the main problems Sudograph will have scaling across multiple canisters is ensuring efficient and complex querying. Indexes and filters will need to work across multiple canisters.</p>
<p>One reason Sudograph is waiting to implement scaling, is to lock down an amazing single canister development experience first. This should be sufficient for many new developers and young projects.</p>
<p>wasm64</p>
<p>multiple memories</p>
<p>infinite virtual memory</p>
<p>You now have everything you need to deploy a simple <code>graphql canister</code>. Boot up a node with <code>dfx start</code> and then deploy with <code>dfx deploy</code>. It's important to note that Sudograph currently only works within a single canister. You can deploy as many Sudograph canisters as you'd like, with as many schemas as you'd like, but the generated querying and mutations will only know about data that has been created within the same canister. Querying between canisters would require you to write your own custom code. Sudograph will hopefully address scaling in the future so that you only ever have to deal with thinking about one schema per application.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="src/graphql-theme.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
