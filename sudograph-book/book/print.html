<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sudograph</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="sudograph.html"><strong aria-hidden="true">1.</strong> Sudograph</a></li><li class="chapter-item expanded "><a href="quickest-of-quick-starts.html"><strong aria-hidden="true">2.</strong> Quickest of quick starts</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">3.</strong> Quick start</a></li><li class="chapter-item expanded "><a href="graphql-database-canister.html"><strong aria-hidden="true">4.</strong> GraphQL database canister</a></li><li class="chapter-item expanded "><a href="sudograph-client.html"><strong aria-hidden="true">5.</strong> Sudograph Client</a></li><li class="chapter-item expanded "><a href="schema.html"><strong aria-hidden="true">6.</strong> Schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="schema-scalars.html"><strong aria-hidden="true">6.1.</strong> Scalars</a></li><li class="chapter-item expanded "><a href="schema-objects.html"><strong aria-hidden="true">6.2.</strong> Objects</a></li><li class="chapter-item expanded "><a href="schema-relations.html"><strong aria-hidden="true">6.3.</strong> Relations</a></li><li class="chapter-item expanded "><a href="schema-custom-scalars.html"><strong aria-hidden="true">6.4.</strong> Custom scalars</a></li><li class="chapter-item expanded "><a href="schema-custom-resolvers.html"><strong aria-hidden="true">6.5.</strong> Custom resolvers</a></li><li class="chapter-item expanded "><a href="schema-sudograph-settings.html"><strong aria-hidden="true">6.6.</strong> Sudograph settings</a></li></ol></li><li class="chapter-item expanded "><a href="generated-schema.html"><strong aria-hidden="true">7.</strong> Generated schema</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="query.html"><strong aria-hidden="true">7.1.</strong> Query</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="read.html"><strong aria-hidden="true">7.1.1.</strong> read</a></li></ol></li><li class="chapter-item expanded "><a href="mutation.html"><strong aria-hidden="true">7.2.</strong> Mutation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="create.html"><strong aria-hidden="true">7.2.1.</strong> create</a></li><li class="chapter-item expanded "><a href="update.html"><strong aria-hidden="true">7.2.2.</strong> update</a></li><li class="chapter-item expanded "><a href="delete.html"><strong aria-hidden="true">7.2.3.</strong> delete</a></li></ol></li><li class="chapter-item expanded "><a href="subscription.html"><strong aria-hidden="true">7.3.</strong> Subscription</a></li><li class="chapter-item expanded "><a href="filtering.html"><strong aria-hidden="true">7.4.</strong> Filtering</a></li><li class="chapter-item expanded "><a href="paging.html"><strong aria-hidden="true">7.5.</strong> Paging</a></li><li class="chapter-item expanded "><a href="ordering.html"><strong aria-hidden="true">7.6.</strong> Ordering</a></li></ol></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">8.</strong> Examples</a></li><li class="chapter-item expanded "><a href="migrations.html"><strong aria-hidden="true">9.</strong> Migrations</a></li><li class="chapter-item expanded "><a href="transactions.html"><strong aria-hidden="true">10.</strong> Transactions</a></li><li class="chapter-item expanded "><a href="vision.html"><strong aria-hidden="true">11.</strong> Vision</a></li><li class="chapter-item expanded "><a href="motivation.html"><strong aria-hidden="true">12.</strong> Motivation</a></li><li class="chapter-item expanded "><a href="limitations.html"><strong aria-hidden="true">13.</strong> Limitations</a></li><li class="chapter-item expanded "><a href="multi-canister-scaling.html"><strong aria-hidden="true">14.</strong> Multi-canister scaling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Sudograph</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="sudograph"><a class="header" href="#sudograph">Sudograph</a></h1>
<p>Sudograph is a <a href="https://graphql.org/">GraphQL</a> database for the <a href="https://dfinity.org/">Internet Computer</a> (IC).</p>
<p>Its goal is to become the simplest way to develop applications for the IC. Developers start by defining a <a href="https://graphql.org/learn/schema/">GraphQL schema</a> using the <a href="https://www.digitalocean.com/community/tutorials/graphql-graphql-sdl">GraphQL SDL</a>. Once the schema is defined, it can be included within a canister and deployed to the IC. An entire relational database is generated from the schema, with GraphQL queries and mutations enabling a variety of <a href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> operations, including advanced querying over relational data.</p>
<p>Sudograph should be considered somewhere between alpha and beta software.</p>
<h2 id="quickest-of-quick-starts"><a class="header" href="#quickest-of-quick-starts">Quickest of quick starts</a></h2>
<p>If you've already got Node.js, npm, Rust, the wasm32-unknown-unknown Rust compilation target, and dfx 0.7.0 installed then just run the following commands:</p>
<pre><code class="language-bash">mkdir my-new-project
cd my-new-project
npx sudograph
dfx start --background
dfx deploy
</code></pre>
<p>Once deployed, you can visit the following canisters from a Chromium browser:</p>
<ul>
<li>playground: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a></li>
<li>frontend: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a></li>
</ul>
<p>If the above did not work, try the full installation steps in the actual quick start.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You should have the following installed on your system:</p>
<ul>
<li>Node.js</li>
<li>npm</li>
<li>Rust</li>
<li>wasm32-unknown-unknown Rust compilation target</li>
<li>dfx 0.7.0</li>
</ul>
<p>If you already have the above installed, you can skip to <a href="quick-start.html#sudograph-generate">Sudograph generate</a>.</p>
<p>Run the following commands to install Node.js and npm. <a href="https://github.com/nvm-sh/nvm">nvm</a> is highly recommended and its use is shown below:</p>
<pre><code class="language-bash">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash

# restart your terminal

nvm install 14
</code></pre>
<p>Run the following command to install Rust and the wasm32-unknown-unknown target:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

rustup target add wasm32-unknown-unknown
</code></pre>
<p>Run the following command to install dfx 0.7.0:</p>
<pre><code class="language-bash"># Sudograph has been tested against version 0.7.0, so it is safest to install that specific version for now
DFX_VERSION=0.7.0 sh -ci &quot;$(curl -fsSL https://sdk.dfinity.org/install.sh)&quot;
</code></pre>
<h3 id="sudograph-generate"><a class="header" href="#sudograph-generate">Sudograph generate</a></h3>
<p>Start by making a new directory for your project. You then simply run the sudograph generate command:</p>
<pre><code class="language-bash">mkdir my-new-project

cd my-new-project

npx sudograph
</code></pre>
<h3 id="local-deployment"><a class="header" href="#local-deployment">Local deployment</a></h3>
<p>Start up an IC replica and deploy:</p>
<pre><code class="language-bash"># Open a terminal and run the following command to start a local IC replica
dfx start

# Alternatively to the above command, you can run the replica in the background
dfx start --background

# If you are running the replica in the background, you can run this command within the same terminal as the dfx start --background command
# If you are not running the replica in the background, then open another terminal and run this command from the root directory of your project
dfx deploy
</code></pre>
<p>Make sure to run <code>dfx deploy</code> for your first deploy. For quicker deployments after the first, you can run <code>dfx deploy graphql</code> if you've only changed your schema or the Rust code within the graphql canister. <code>dfx deploy graphql</code> will only deploy the graphql canister, which contains the generated database.</p>
<h4 id="playground-canister"><a class="header" href="#playground-canister">playground canister</a></h4>
<p>Start executing GraphQL queries and mutations against your database by going to the following URL in a Chromium browser: <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a>.</p>
<h4 id="frontend-canister"><a class="header" href="#frontend-canister">frontend canister</a></h4>
<p>View a simple frontend application that communicates with the graphql canister by going to the following URL in a Chromium browser: <a href="http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000">http://rrkah-fqaaa-aaaaa-aaaaq-cai.localhost:8000</a>.</p>
<h4 id="graphql-canister"><a class="header" href="#graphql-canister">graphql canister</a></h4>
<p>You can execute queries against the graphql canister from the command line if you wish:</p>
<pre><code class="language-bash"># send a query to the graphql canister
dfx canister call graphql graphql_query '(&quot;query { readUser { id } }&quot;, &quot;{}&quot;)'

# send a mutation to the graphql canister
dfx canister call graphql graphql_mutation '(&quot;mutation { createUser(input: { username: \&quot;lastmjs\&quot; }) { id } }&quot;, &quot;{}&quot;)'
</code></pre>
<h3 id="production-deployment"><a class="header" href="#production-deployment">Production deployment</a></h3>
<p>Before deploying to production you should understand that Sudograph is alpha/beta software. There are missing features and potential bugs. There is also no way to easily migrate data (if you change your schema, you'll need to delete your state and start over). But if you must deploy to production, here is the command:</p>
<pre><code class="language-bash">dfx deploy --network ic
</code></pre>
<h1 id="graphql-database-canister"><a class="header" href="#graphql-database-canister">GraphQL database canister</a></h1>
<p>Sudograph provides one main entrypoint for creating your GraphQL database, and that is the <code>graphql_database</code> Rust procedural macro. Using the power of Rust procedural macros, <code>graphql_database</code> will take your GraphQL schema file and generate all code required to turn the types defined in your schema into a functioning CRUD database.</p>
<p>To use <code>graphql_database</code>, first create a new Rust canister. If you're new to developing for the Internet Computer, you might want to check the <a href="https://sdk.dfinity.org/docs/quickstart/quickstart-intro.html">documentation</a> to get familiar with canister development.</p>
<p>Add a new canister to your <code>dfx.json</code>. You can name the canister whatever you'd like, but to keep things simple the canister defined below is named <code>graphql</code>. The contents of your <code>dfx.json</code> should look like the following. If you have other canisters already defined, just add the <code>graphql</code> canister:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<p>The canister defined above assumes a directory structure where <code>dfx.json</code> is in the root of your project, and there is a directory called <code>canisters</code> to contain each canister. You can change up the directory structure if you'd like, just change all of the paths appropriately. Create a new directory within canisters called <code>graphql</code>, and add a <code>Cargo.toml</code> file. It should look something like the following:</p>
<pre><code class="language-toml">[package]
name = &quot;graphql&quot;
version = &quot;0.0.0&quot;
edition = &quot;2018&quot;

[lib]
path = &quot;src/graphql.rs&quot;
crate-type = [&quot;cdylib&quot;]

[dependencies]
sudograph = &quot;0.2.0&quot;
</code></pre>
<p>Within the <code>canisters/graphql</code> directory, now create a <code>src</code> directory. The <code>canisters/graphql/src</code> directory will contain the entrypoint to your <code>graphql</code> canister, <code>graphql.rs</code>, along with your <code>schema.graphql</code> file and your <code>graphql.did</code> file.</p>
<p>The <code>graphql.rs</code> file should look like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sudograph::graphql_database;

graphql_database!(&quot;canisters/graphql/src/schema.graphql&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This simply imports the <code>graphql_database</code> procedural macro from <code>sudograph</code> and then invokes it with the path to your <code>schema.graphql</code> file.</p>
<p>You must also create a custom candid file <code>graphql.did</code>:</p>
<pre><code>service : {
    &quot;graphql_query&quot;: (text, text) -&gt; (text) query;
    &quot;graphql_mutation&quot;: (text, text) -&gt; (text);
}
</code></pre>
<p>The generated canister code will have created the two functions defined in <code>graphql.did</code>, but for now you'll need to create the candid file manually. Hopefully in the future it can be generated for you or abstracted away somehow.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both take two parameters. The first parameter is the query or mutation string. The second parameter is a JSON string containing any variables for the query or mutation. Currently the second parameter is required, so just send an empty JSON object strin <code>&quot;{}&quot;</code> if no variables are required for the query or mutation.</p>
<p><code>graphql_query</code> and <code>graphql_mutation</code> both return the result of the query or mutation as a JSON string. Whatever client is consuming the query or mutation will then need to parse the JSON string to turn it into a language-level object. The <a href="https://www.npmjs.com/package/sudograph">Sudograph Client</a> will do this for you in a JavaScript frontend.</p>
<p>Finally create your <code>schema.graphql</code> file:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}
</code></pre>
<p>You now have everything you need to deploy a simple <code>graphql canister</code>. Boot up a node with <code>dfx start</code> and then deploy with <code>dfx deploy</code>. It's important to note that Sudograph currently only works within a single canister. You can deploy as many Sudograph canisters as you'd like, with as many schemas as you'd like, but the generated querying and mutations will only know about data that has been created within the same canister. Querying between canisters would require you to write your own custom code. Sudograph will hopefully address scaling in the future so that you only ever have to deal with thinking about one schema per application.</p>
<h2 id="rust-wasm-binary-optimization"><a class="header" href="#rust-wasm-binary-optimization">Rust Wasm binary optimization</a></h2>
<p>At some point your compiled Rust Wasm binary will grow too large and will be rejected by the canister on deploy. This could happen because the Rust source code that you've written has grown too large, or because your schema has grown too large. A large schema will lead to a large amount of generated Rust code.</p>
<p>To temporarily overcome this issue (only so much can be done during optimization, eventually the binary will be too big and the Internet Computer will need to address that), you can optimize your Rust Wasm binary.</p>
<h3 id="manual-optimization"><a class="header" href="#manual-optimization">Manual optimization</a></h3>
<p>To do this manually, in the root of your directory run the following command once to install the optimizer:</p>
<pre><code class="language-bash">cargo install ic-cdk-optimizer --root target
</code></pre>
<p>You should also change your <code>dfx.json</code> file from:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;
        }
    }
}
</code></pre>
<p>to:</p>
<pre><code class="language-json">{
    &quot;canisters&quot;: {
        &quot;graphql&quot;: {
            &quot;type&quot;: &quot;custom&quot;,
            &quot;build&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
            &quot;candid&quot;: &quot;canisters/graphql/src/graphql.did&quot;,
            &quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;
        }
    }
}
</code></pre>
<p>The only thing that changed was the <code>wasm</code> property of the <code>graphql</code> canister object, and it changed from <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql.wasm&quot;</code> to <code>&quot;wasm&quot;: &quot;target/wasm32-unknown-unknown/release/graphql-optimized.wasm&quot;</code>.</p>
<p>Each time you run <code>dfx deploy</code> or <code>dfx deploy graphql</code>, you will need to run the following command after:</p>
<pre><code class="language-bash">./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimized.wasm
</code></pre>
<h3 id="automatic-optimization"><a class="header" href="#automatic-optimization">Automatic optimization</a></h3>
<p>It can be tedious to have to run the above command manually after each <code>dfx deploy</code>. If you wish to figure out how to use <code>cargo</code> scripts of some kind you can do that. You could also use <code>make</code> or <code>bash</code> or some other build process or scripting system.</p>
<p>Another way is to adopt npm scripts. Your <code>package.json</code> could look something like this:</p>
<pre><code class="language-json">{
    &quot;scripts&quot;: {
        &quot;build&quot;: &quot;cd canisters/playground &amp;&amp; npm install &amp;&amp; npm run build &amp;&amp; cd ../frontend &amp;&amp; npm install &amp;&amp; npm run build&quot;,
        &quot;dfx-deploy&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy&quot;,
        &quot;dfx-deploy-graphql&quot;: &quot;npm run dfx-build-graphql &amp;&amp; npm run dfx-optimize-graphql &amp;&amp; dfx deploy graphql&quot;,
        &quot;dfx-build-graphql&quot;: &quot;cargo build --target wasm32-unknown-unknown --package graphql --release&quot;,
        &quot;dfx-optimize-graphql&quot;: &quot;./target/bin/ic-cdk-optimizer ./target/wasm32-unknown-unknown/release/graphql.wasm -o ./target/wasm32-unknown-unknown/release/graphql-optimised.wasm&quot;
    }
}
</code></pre>
<p>Then instead of running <code>dfx deploy</code> or <code>dfx deploy graphql</code> you would run <code>npm run dfx-deploy</code> or <code>npm run dfx-deploy-graphql</code>.</p>
<p>In the future it would be nice for the <code>dfx.json</code> to allow for some sort of build scripts, which would make this process less messy. There is an open forum post about this here: https://forum.dfinity.org/t/dfx-json-build-scripts/4922</p>
<h1 id="sudograph-client"><a class="header" href="#sudograph-client">Sudograph Client</a></h1>
<p>This is not yet well-documented. You can look at the examples to see how to use it in a JavaScript frontend. <code>npm install sudograph</code> and go from there.</p>
<h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>The schema is where you define all of the data types of your application, including relations between types. It is also where you will eventually define many other settings, possibly including authentication, authorization, subnet, and Sudograph-specific settings.</p>
<p>An example schema might look like this:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}
</code></pre>
<p>We have told Sudograph that we have two object types, <code>User</code> and <code>BlogPost</code>. We've described the fields of each type, using some included scalar types such as <code>ID</code>, <code>Date</code>, and <code>String</code>. We have also described one relation between our two types, a one-to-many relationship from <code>User</code> to <code>BlogPost</code> on the fields <code>User:blogPosts</code> and <code>BlogPost:author</code>.</p>
<p>The schema is an incredibly powerful yet simple tool for defining the complex data types of your application. Get to know the possibilities of your schema:</p>
<ul>
<li><a href="./schema-scalars.html">Scalars</a></li>
<li><a href="./schema-objects.html">Objects</a></li>
<li><a href="./schema-relations.html">Relations</a></li>
<li><a href="./schema-custom-scalars.html">Custom scalars</a></li>
<li><a href="./schema-custom-resolvers.html">Custom resolvers</a></li>
<li><a href="./schema-sudograph-settings.html">Sudograph settings</a></li>
</ul>
<h1 id="scalars"><a class="header" href="#scalars">Scalars</a></h1>
<p>Scalar types are not divisible, they have no fields of their own. The scalar types automatically available to you in a Sudograph schema are:</p>
<ul>
<li><a href="schema-scalars.html#boolean">Boolean</a></li>
<li><a href="schema-scalars.html#date">Date</a></li>
<li><a href="schema-scalars.html#float">Float</a></li>
<li><a href="schema-scalars.html#id">ID</a></li>
<li><a href="schema-scalars.html#int">Int</a></li>
<li><a href="schema-scalars.html#string">String</a></li>
</ul>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>A <code>Boolean</code> value maps to a Rust <code>bool</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    verified: Boolean!
}
</code></pre>
<h2 id="date"><a class="header" href="#date">Date</a></h2>
<p>A <code>Date</code> value maps to a Rust <code>String</code> for storage and a <a href="https://docs.rs/chrono/0.4.19/chrono/struct.DateTime.html">chrono::DateTime</a> for filtering.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    dateOfBirth: Date!
}
</code></pre>
<h2 id="float"><a class="header" href="#float">Float</a></h2>
<p>A <code>Float</code> value maps to a Rust <code>f32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    height: Float!
}
</code></pre>
<h2 id="id"><a class="header" href="#id">ID</a></h2>
<p>An <code>ID</code> value maps to a Rust <code>String</code>. All Sudograph object types must have a field called <code>id</code> of type <code>ID</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
}
</code></pre>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<p>An <code>Int</code> value maps to a Rust <code>i32</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    age: Int!
}
</code></pre>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<p>A <code>String</code> value maps to a Rust <code>String</code>.</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
}
</code></pre>
<h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<p>Object types have fields that may be other object types or scalar types. Object types allow you to define the truly custom data types and relations that make up your application.</p>
<p>You could model a user with blog posts like so:</p>
<pre><code class="language-graphql">type User {
    id: ID!
    username: String!
    blogPosts: [BlogPost!]! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}

type BlogPost {
    id: ID!
    publishedAt: Date
    title: String!
    author: User! @relation(name: &quot;User:blogPosts and BlogPost:author&quot;)
}
</code></pre>
<p>You could model a family tree like so:</p>
<pre><code class="language-graphql">type Person {
    id: ID!
    firstName: String!
    lastName: String!
    father: Person @relation(name: &quot;Person:father and Person:children&quot;)
    mother: Person @relation(name: &quot;Person:mother and Person:children&quot;)
    children: [Person!]!
        @relation(name: &quot;Person:father and Person:children&quot;)
        @relation(name: &quot;Person:mother and Person:children&quot;)
}
</code></pre>
<p>TODO the example above will not work yet</p>
<p>TODO the self-referencing has some issues and multiple @relation directives per field is not yet supported</p>
<p>You could model Ethereum block data like so:</p>
<pre><code class="language-graphql">type Block {
    id: ID!
    number: Int!
    hash: String!
    parent: Block
    transactionsRoot: String!
    transactionCount: Int!
    stateRoot: String!
    gasLimit: String!
    gasUsed: String!
    timestamp: Date!
    transactions: [Transaction!]! @relation(name: &quot;Block:transactions and Transaction:block&quot;)
}

type Transaction {
    id: ID!
    hash: String!
    index: Int!
    from: String!
    to: String!
    value: String!
    gasPrice: String!
    gas: String!
    inputData: String!
    block: Block! @relation(name: &quot;Block:transactions and Transaction:block&quot;)
    gasUsed: String!
}
</code></pre>
<h1 id="relations"><a class="header" href="#relations">Relations</a></h1>
<p>Relations allow you to describe the relationships between object types and their fields. Sudograph has a variety of relation capabilities:</p>
<h2 id="one-to-one-relations"><a class="header" href="#one-to-one-relations">One-to-one relations</a></h2>
<p>One-to-one relations allow you to connect one object with another object.</p>
<h3 id="one-sided"><a class="header" href="#one-sided">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe
}

type Shoe {
    id: ID!
}
</code></pre>
<p>In the above example, you will be able to select the shoe of a foot, like so:</p>
<pre><code class="language-graphql">query {
    readFoot(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        shoe {
            id
        }
    }
}
</code></pre>
<p>You will not be able to select the foot of a shoe.</p>
<h3 id="two-sided"><a class="header" href="#two-sided">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Foot {
    id: ID!
    shoe: Shoe @relation(name: &quot;Foot:shoe and Shoe:foot&quot;)
}

type Shoe {
    id: ID!
    foot: Foot @relation(name: &quot;Foot:shoe and Shoe:foot&quot;)
}
</code></pre>
<h2 id="one-to-many-relations"><a class="header" href="#one-to-many-relations">One-to-many relations</a></h2>
<p>One-to-many relations allow you to connect one object with multiple other objects.</p>
<h3 id="one-sided-1"><a class="header" href="#one-sided-1">One-sided</a></h3>
<p>If you only care about retrieving relation information from one side of the relation, you don't need a <code>@relation</code> directive:</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]!
}

type Banana {
    id: ID!
    color: String!
    size: Int!
}
</code></pre>
<p>In the above example, you will be able to select the bananas of a monkey, like so:</p>
<pre><code class="language-graphql">query {
    readMonkey(search: {
        id: {
            eq: &quot;7c3nrr-6jhf3-2gozt-hh37a-d6nvf-lsdwv-d7bhp-uk5nt-r42y&quot;
        }
    }) {
        id
        name
        bananas {
            id
            color
            size
        }
    }
}
</code></pre>
<p>You will not be able to select the monkey of a banana.</p>
<h3 id="two-sided-1"><a class="header" href="#two-sided-1">Two-sided</a></h3>
<p>If you care about retrieving relation information from both sides of the relation, add a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Monkey {
    id: ID!
    name: String!
    bananas: [Banana!]! @relation(name: &quot;Monkey:bananas and Banana:monkey&quot;)
}

type Banana {
    id: ID!
    color: String!
    size: Int!
    monkey: Monkey @relation(name: &quot;Monkey:bananas and Banana:monkey&quot;)
}
</code></pre>
<h2 id="many-to-many-relations"><a class="header" href="#many-to-many-relations">Many-to-many relations</a></h2>
<p>Many-to-many relations allow you to connect multiple objects with multiple other objects. Many-to-many relations must have a <code>@relation</code> directive. The name argument of the <code>@relation</code> directive can be arbitrary, but it must be the same on both sides of the relation.</p>
<pre><code class="language-graphql">type Author {
    id: ID!
    documents: [Document!]! @relation(name: &quot;Author:documents and Document:authors&quot;)
}

type Document {
    id: ID!
    text: String!
    authors: [Author!]! @relation(name: &quot;Author:documents and Document:authors&quot;)
}
</code></pre>
<h1 id="custom-scalars"><a class="header" href="#custom-scalars">Custom scalars</a></h1>
<p>Custom scalars (scalars that you define) are not yet supported. You'll have to work with the included scalars:</p>
<ul>
<li><a href="./schema-scalars.html#boolean">Boolean</a></li>
<li><a href="./schema-scalars.html#date">Date</a></li>
<li><a href="./schema-scalars.html#float">Float</a></li>
<li><a href="./schema-scalars.html#id">ID</a></li>
<li><a href="./schema-scalars.html#int">Int</a></li>
<li><a href="./schema-scalars.html#string">String</a></li>
</ul>
<h1 id="custom-resolvers"><a class="header" href="#custom-resolvers">Custom resolvers</a></h1>
<p>Custom resolvers where the resolver function is defined within the same Rust canister as the <code>graphql_database</code> macro are possible now, but not well-documented.  See the <a href="https://github.com/sudograph/sudograph/tree/main/examples/intermediate">intermediate example</a> for a very rough overview of how to achieve this.</p>
<p>Custom resolvers where the resolver function is defined in a separate canister (be it written in Rust, Motoko, AssemblyScript, or any other language) are also supported. For now you will need to write a custom resolver in Rust that does a cross-canister call to the resolver in the separate canister. This is not well-documented but is possible. In the future, the plan is for those types of custom resolvers to be defined only in the schema so that no Rust code is required. It will look like this:</p>
<pre><code class="language-graphql"># schema.graphql

type Query {
    myCustomQueryResolver(param1: Int!): Boolean! @canister(id: &quot;renrk-eyaaa-aaaaa-aaada-cai&quot;)
}

type Mutation {
    myCustomMutationResolver(param1: Float!): String! @canister(id: &quot;rdmx6-jaaaa-aaaaa-aaadq-cai&quot;)
}
</code></pre>
<p>Defining the above <code>Query</code> and <code>Mutation</code> object types in your schema would generate two custom resolver functions in the Rust canister where the <code>graphql_database</code> macro is used. These resolver functions would perform cross-canister calls to a canister with the id defined in the <code>@canister</code> directive. You would then need to define <code>myCustomQueryResolver</code> with the appropriate parameters and return type in the <code>renrk-eyaaa-aaaaa-aaada-cai</code> canister, and <code>myCustomMutationResolver</code> with the appropriate parameters and return type in the <code>rdmx6-jaaaa-aaaaa-aaadq-cai</code> canister.</p>
<h1 id="sudograph-settings"><a class="header" href="#sudograph-settings">Sudograph settings</a></h1>
<p>There will be many settings that Sudograph will allow the developer to customize. Currently however, none of these settings are possible to change. But here is how it might eventually look to change settings:</p>
<pre><code class="language-graphql">type SudographSettings {
    exportGeneratedGraphQLQueryFunction: false
    exportGenerateGraphQLMutationFunction: true
    exportGeneratedInitFunction: true
    exportGeneratedPostUpgradeFunction: false
}
</code></pre>
<h1 id="generated-schema"><a class="header" href="#generated-schema">Generated Schema</a></h1>
<p>Sudograph takes your <a href="./schema.html">schema</a> and generates a much more powerful schema.</p>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="query"><a class="header" href="#query">Query</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="read"><a class="header" href="#read">read</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="mutation"><a class="header" href="#mutation">Mutation</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="create"><a class="header" href="#create">create</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="update"><a class="header" href="#update">update</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="delete"><a class="header" href="#delete">delete</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="subscription"><a class="header" href="#subscription">Subscription</a></h1>
<p>This is not yet implemented</p>
<h1 id="filtering"><a class="header" href="#filtering">Filtering</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="paging"><a class="header" href="#paging">Paging</a></h1>
<p>Not yet implemented</p>
<h1 id="ordering"><a class="header" href="#ordering">Ordering</a></h1>
<p>Not yet implemented</p>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>This section is not yet well-documented, but assuming you've generated an example project with <code>npx sudograph</code> and deployed your canisters, then navigate to the playground at <a href="http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000">http://r7inp-6aaaa-aaaaa-aaabq-cai.localhost:8000</a> in a Chromium browser and click the Docs button in the top right corner. That documentation explains everything that you can do with your newly generated schema.</p>
<h1 id="migrations"><a class="header" href="#migrations">Migrations</a></h1>
<p>Automated migrations are not currently supported. If you wish to update a Sudograph canister that has already been deployed, you will lose all of your saved data unless you implement your own migrations.</p>
<p>You can implement your own migrations by implementing and exporting <code>pre_upgrade</code> and <code>post_upgrade</code> canister functions. You can save your state to stable memory in the <code>pre_upgrade</code> function, and restore that state in the <code>post_upgrade</code> function. See <a href="https://sdk.dfinity.org/docs/developers-guide/working-with-canisters.html">here</a> and <a href="https://github.com/dfinity/cdk-rs/blob/main/examples/asset_storage/src/asset_storage_rs/lib.rs">here</a> for more information.</p>
<p>The plan is to eventually automate migrations as much as possible. If you change your schema and wish to update it on a live canister, Sudograph will generate migrations written in Rust to accomplish the migration for you. If a migration cannot be performed automatically, Sudograph will allow you to easily define your own migration code in Rust. That's the rough plan for now.</p>
<p>But until then, you're on your own. Good luck soldier.</p>
<h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>Sudograph does not have a strong guarantee of atomicity (transactions) at this time. Read on for more information.</p>
<h2 id="single-canister-mutations"><a class="header" href="#single-canister-mutations">Single canister mutations</a></h2>
<p>Within a single update call, transactions are automatically handled by the Internet Computer itself! If there are any errors (technically Wasm traps) all state changes are undone and thus not persisted.</p>
<p>This is a very nice feature of single canister development. If you don't know already you need to know that the schema that Sudograph generates for you is limited to a single canister by default. If you need to scale across canisters, you will need to write custom code.</p>
<p>Unfortunately, Sudograph does not currently guarantee that all errors will lead to traps that undo all state changes. It should not be too difficult to add, but currently you do not have a guarantee that all mutations within a single update call will be executed atomically.</p>
<p>Once Sudograph ensures all errors will lead to traps, you will be able to ensure atomicity by executing many mutations within a single update call like this:</p>
<pre><code class="language-graphql">mutation {
    createUser1: createUser(input: {
        username: &quot;user1&quot;
    }) {
        id
    }

    createUser2: createUser(input: {
        username: &quot;user2&quot;
    }) {
        id
    }

    createUser3: createUser(input: {
        username: &quot;user3&quot;
    }) {
        id
    }
}
</code></pre>
<p>All of the mutations above will either all succeed or all fail.</p>
<h2 id="multi-canister-mutations"><a class="header" href="#multi-canister-mutations">Multi-canister mutations</a></h2>
<p>Even if you batch many mutations into one update call, if any of your mutations are custom and call into other canisters, the atomic guarantees are gone. This will be more difficult for Sudograph to implement because the Internet Computer does not provide atomicity when doing multi-canister updates.</p>
<p>If you need transactions across multiple canisters, you will need to write custom code that undoes state changes across all canisters in a chain of mutations.</p>
<h1 id="vision"><a class="header" href="#vision">Vision</a></h1>
<p>Not yet well-documented, sheesh!</p>
<h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Not yet well-documented, sheesh!</p>
<h1 id="limitations"><a class="header" href="#limitations">Limitations</a></h1>
<ul>
<li><input disabled="" type="checkbox"/>
No paging or ordering of records</li>
<li><input disabled="" type="checkbox"/>
No custom scalars, only Int, Float, String, ID, Boolean, and Date are available</li>
<li><input disabled="" type="checkbox"/>
Filtering is limited to the top level selection set</li>
<li><input disabled="" type="checkbox"/>
Limited to a single canister ~4GB of storage</li>
<li><input disabled="" type="checkbox"/>
Very inneficient querying, be careful once you get into the 100,000s or 1,000,000s of records</li>
<li><input disabled="" type="checkbox"/>
No automatic migrations, once you deploy the schema is final unless you implement your own migrations</li>
<li><input disabled="" type="checkbox"/>
No authorization at the schema level, deal with it through your own custom authorization at the canister function level</li>
<li><input disabled="" type="checkbox"/>
No automated tests</li>
<li><input disabled="" type="checkbox"/>
No subscriptions</li>
<li><input disabled="" type="checkbox"/>
No transactions</li>
</ul>
<h1 id="multi-canister-scaling"><a class="header" href="#multi-canister-scaling">Multi-canister scaling</a></h1>
<p>Sudograph will not scale a single schema across multiple canisters automatically. The goal is to eventually provide this functionality, but the timeline and feasibility of this goal are unknown.</p>
<p>Currently each schema that you deploy into a canister is limited to ~4GB of data. This should be sufficient for prototyping and small amounts of storage and usage. There are also multiple scaling techniques that could be used to scale out, for example by storing large files (video, audio, images, documents) in a separate set of canisters that has automatic scaling built-in, and storing references to that data in your Sudograph canister.</p>
<p>One of the main problems Sudograph will have scaling across multiple canisters is ensuring efficient and complex querying. Indexes and filters will need to work across multiple canisters.</p>
<p>One reason Sudograph is waiting to implement scaling, is to lock down an amazing single canister development experience first. This should be sufficient for many new developers and young projects.</p>
<p>wasm64</p>
<p>multiple memories</p>
<p>infinite virtual memory</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="src/graphql-theme.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
